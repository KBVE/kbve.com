const c=Math.PI,x=2*c,u=1e-6,m=x-u;function E(t){this._+=t[0];for(let i=1,s=t.length;i<s;++i)this._+=arguments[i]+t[i]}function A(t){let i=Math.floor(t);if(!(i>=0))throw new Error(`invalid digits: ${t}`);if(i>15)return E;const s=10**i;return function(t){this._+=t[0];for(let i=1,h=t.length;i<h;++i)this._+=Math.round(arguments[i]*s)/s+t[i]}}class L{constructor(t){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=null==t?E:A(t)}moveTo(t,i){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+i}`}closePath(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(t,i){this._append`L${this._x1=+t},${this._y1=+i}`}quadraticCurveTo(t,i,s,h){this._append`Q${+t},${+i},${this._x1=+s},${this._y1=+h}`}bezierCurveTo(t,i,s,h,n,_){this._append`C${+t},${+i},${+s},${+h},${this._x1=+n},${this._y1=+_}`}arcTo(t,i,s,h,n){if(t=+t,i=+i,s=+s,h=+h,(n=+n)<0)throw new Error(`negative radius: ${n}`);let _=this._x1,e=this._y1,$=s-t,a=h-i,r=_-t,o=e-i,l=r*r+o*o;if(null===this._x1)this._append`M${this._x1=t},${this._y1=i}`;else if(l>u)if(Math.abs(o*$-a*r)>u&&n){let p=s-_,x=h-e,d=$*$+a*a,f=p*p+x*x,M=Math.sqrt(d),y=Math.sqrt(l),g=n*Math.tan((c-Math.acos((d+l-f)/(2*M*y)))/2),w=g/y,v=g/M;Math.abs(w-1)>u&&this._append`L${t+w*r},${i+w*o}`,this._append`A${n},${n},0,0,${+(o*p>r*x)},${this._x1=t+v*$},${this._y1=i+v*a}`}else this._append`L${this._x1=t},${this._y1=i}`}arc(t,i,s,h,n,_){if(t=+t,i=+i,_=!!_,(s=+s)<0)throw new Error(`negative radius: ${s}`);let e=s*Math.cos(h),$=s*Math.sin(h),a=t+e,r=i+$,o=1^_,l=_?h-n:n-h;null===this._x1?this._append`M${a},${r}`:(Math.abs(this._x1-a)>u||Math.abs(this._y1-r)>u)&&this._append`L${a},${r}`,s&&(l<0&&(l=l%x+x),l>m?this._append`A${s},${s},0,1,${o},${t-e},${i-$}A${s},${s},0,1,${o},${this._x1=a},${this._y1=r}`:l>u&&this._append`A${s},${s},0,${+(l>=c)},${o},${this._x1=t+s*Math.cos(n)},${this._y1=i+s*Math.sin(n)}`)}rect(t,i,s,h){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+i}h${s=+s}v${+h}h${-s}Z`}toString(){return this._}}function P(t){return function(){return t}}function q(t){let i=3;return t.digits=function(s){if(!arguments.length)return i;if(null==s)i=null;else{const t=Math.floor(s);if(!(t>=0))throw new RangeError(`invalid digits: ${s}`);i=t}return t},()=>new L(i)}export{P as c,q as w};