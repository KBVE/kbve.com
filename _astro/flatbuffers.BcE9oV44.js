var l=(i=>(i[i.WIDTH8=0]="WIDTH8",i[i.WIDTH16=1]="WIDTH16",i[i.WIDTH32=2]="WIDTH32",i[i.WIDTH64=3]="WIDTH64",i))(l||{});function B(i){return 1<<i}function F(i){return i>=-128&&i<=127?l.WIDTH8:i>=-32768&&i<=32767?l.WIDTH16:i>=-2147483648&&i<=2147483647?l.WIDTH32:l.WIDTH64}function H(i){return i===Math.fround(i)?l.WIDTH32:l.WIDTH64}function y(i){return i<=255?l.WIDTH8:i<=65535?l.WIDTH16:i<=4294967295?l.WIDTH32:l.WIDTH64}function p(i){return i===1?l.WIDTH8:i===2?l.WIDTH16:i===4?l.WIDTH32:l.WIDTH64}function D(i,t){return~i+1&t-1}function m(i){return new TextDecoder().decode(i)}function U(i){return new TextEncoder().encode(i)}var n=(i=>(i[i.NULL=0]="NULL",i[i.INT=1]="INT",i[i.UINT=2]="UINT",i[i.FLOAT=3]="FLOAT",i[i.KEY=4]="KEY",i[i.STRING=5]="STRING",i[i.INDIRECT_INT=6]="INDIRECT_INT",i[i.INDIRECT_UINT=7]="INDIRECT_UINT",i[i.INDIRECT_FLOAT=8]="INDIRECT_FLOAT",i[i.MAP=9]="MAP",i[i.VECTOR=10]="VECTOR",i[i.VECTOR_INT=11]="VECTOR_INT",i[i.VECTOR_UINT=12]="VECTOR_UINT",i[i.VECTOR_FLOAT=13]="VECTOR_FLOAT",i[i.VECTOR_KEY=14]="VECTOR_KEY",i[i.VECTOR_STRING_DEPRECATED=15]="VECTOR_STRING_DEPRECATED",i[i.VECTOR_INT2=16]="VECTOR_INT2",i[i.VECTOR_UINT2=17]="VECTOR_UINT2",i[i.VECTOR_FLOAT2=18]="VECTOR_FLOAT2",i[i.VECTOR_INT3=19]="VECTOR_INT3",i[i.VECTOR_UINT3=20]="VECTOR_UINT3",i[i.VECTOR_FLOAT3=21]="VECTOR_FLOAT3",i[i.VECTOR_INT4=22]="VECTOR_INT4",i[i.VECTOR_UINT4=23]="VECTOR_UINT4",i[i.VECTOR_FLOAT4=24]="VECTOR_FLOAT4",i[i.BLOB=25]="BLOB",i[i.BOOL=26]="BOOL",i[i.VECTOR_BOOL=36]="VECTOR_BOOL",i))(n||{});function E(i){return i===n.BOOL||i<=n.FLOAT}function A(i){return i>=n.INT&&i<=n.FLOAT}function P(i){return i>=n.INDIRECT_INT&&i<=n.INDIRECT_FLOAT}function K(i){return i===n.BOOL||i>=n.INT&&i<=n.STRING}function S(i){return i===n.VECTOR_BOOL||i>=n.VECTOR_INT&&i<=n.VECTOR_STRING_DEPRECATED}function _(i){return i>=n.VECTOR_INT2&&i<=n.VECTOR_FLOAT4}function V(i){return S(i)||_(i)||i===n.VECTOR}function $(i,t){if(t===0)return i-n.INT+n.VECTOR_INT;if(t===2)return i-n.INT+n.VECTOR_INT2;if(t===3)return i-n.INT+n.VECTOR_INT3;if(t===4)return i-n.INT+n.VECTOR_INT4;throw"Unexpected length "+t}function x(i){return i-n.VECTOR_INT+n.INT}function Y(i){return(i-n.VECTOR_INT2)%3+n.INT}function M(i){return((i-n.VECTOR_INT2)/3>>0)+2}function L(i,t){return t|i<<2}class b{constructor(t,e,s,h=null,r=0){this.builder=t,this.type=e,this.width=s,this.value=h,this.offset=r}elementWidth(t,e){if(E(this.type))return this.width;for(let s=0;s<4;s++){const h=1<<s,c=t+D(t,h)+e*h-this.offset,d=y(c);if(1<<d===h)return d}throw`Element is unknown. Size: ${t} at index: ${e}. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new`}writeToBuffer(t){const e=this.builder.computeOffset(t);if(this.type===n.FLOAT)this.width===l.WIDTH32?this.builder.view.setFloat32(this.builder.offset,this.value,!0):this.builder.view.setFloat64(this.builder.offset,this.value,!0);else if(this.type===n.INT){const s=p(t);this.builder.pushInt(this.value,s)}else if(this.type===n.UINT){const s=p(t);this.builder.pushUInt(this.value,s)}else if(this.type===n.NULL)this.builder.pushInt(0,this.width);else if(this.type===n.BOOL)this.builder.pushInt(this.value?1:0,this.width);else throw`Unexpected type: ${this.type}. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new`;this.offset=e}storedWidth(t=l.WIDTH8){return E(this.type)?Math.max(t,this.width):this.width}storedPackedType(t=l.WIDTH8){return L(this.type,this.storedWidth(t))}isOffset(){return!E(this.type)}}class z{constructor(t=2048,e=!0,s=!0,h=!0){this.dedupStrings=e,this.dedupKeys=s,this.dedupKeyVectors=h,this.stack=[],this.stackPointers=[],this.offset=0,this.finished=!1,this.stringLookup={},this.keyLookup={},this.keyVectorLookup={},this.indirectIntLookup={},this.indirectUIntLookup={},this.indirectFloatLookup={},this.buffer=new ArrayBuffer(t>0?t:2048),this.view=new DataView(this.buffer)}align(t){const e=B(t);return this.offset+=D(this.offset,e),e}computeOffset(t){const e=this.offset+t;let s=this.buffer.byteLength;const h=s;for(;s<e;)s<<=1;if(h<s){const r=this.buffer;this.buffer=new ArrayBuffer(s),this.view=new DataView(this.buffer),new Uint8Array(this.buffer).set(new Uint8Array(r),0)}return e}pushInt(t,e){if(e===l.WIDTH8)this.view.setInt8(this.offset,t);else if(e===l.WIDTH16)this.view.setInt16(this.offset,t,!0);else if(e===l.WIDTH32)this.view.setInt32(this.offset,t,!0);else if(e===l.WIDTH64)this.view.setBigInt64(this.offset,BigInt(t),!0);else throw`Unexpected width: ${e} for value: ${t}`}pushUInt(t,e){if(e===l.WIDTH8)this.view.setUint8(this.offset,t);else if(e===l.WIDTH16)this.view.setUint16(this.offset,t,!0);else if(e===l.WIDTH32)this.view.setUint32(this.offset,t,!0);else if(e===l.WIDTH64)this.view.setBigUint64(this.offset,BigInt(t),!0);else throw`Unexpected width: ${e} for value: ${t}`}writeInt(t,e){const s=this.computeOffset(e);this.pushInt(t,p(e)),this.offset=s}writeUInt(t,e){const s=this.computeOffset(e);this.pushUInt(t,p(e)),this.offset=s}writeBlob(t){const e=t.byteLength,s=y(e),h=this.align(s);this.writeUInt(e,h);const r=this.offset,c=this.computeOffset(e);new Uint8Array(this.buffer).set(new Uint8Array(t),r),this.stack.push(this.offsetStackValue(r,n.BLOB,s)),this.offset=c}writeString(t){if(this.dedupStrings&&Object.prototype.hasOwnProperty.call(this.stringLookup,t)){this.stack.push(this.stringLookup[t]);return}const e=U(t),s=e.length,h=y(s),r=this.align(h);this.writeUInt(s,r);const c=this.offset,d=this.computeOffset(s+1);new Uint8Array(this.buffer).set(e,c);const a=this.offsetStackValue(c,n.STRING,h);this.stack.push(a),this.dedupStrings&&(this.stringLookup[t]=a),this.offset=d}writeKey(t){if(this.dedupKeys&&Object.prototype.hasOwnProperty.call(this.keyLookup,t)){this.stack.push(this.keyLookup[t]);return}const e=U(t),s=e.length,h=this.computeOffset(s+1);new Uint8Array(this.buffer).set(e,this.offset);const r=this.offsetStackValue(this.offset,n.KEY,l.WIDTH8);this.stack.push(r),this.dedupKeys&&(this.keyLookup[t]=r),this.offset=h}writeStackValue(t,e){const s=this.computeOffset(e);if(t.isOffset()){const h=this.offset-t.offset;if(e===8||BigInt(h)<BigInt(1)<<BigInt(e*8))this.writeUInt(h,e);else throw`Unexpected size ${e}. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new`}else t.writeToBuffer(e);this.offset=s}integrityCheckOnValueAddition(){if(this.finished)throw"Adding values after finish is prohibited";if(this.stackPointers.length!==0&&this.stackPointers[this.stackPointers.length-1].isVector===!1&&this.stack[this.stack.length-1].type!==n.KEY)throw"Adding value to a map before adding a key is prohibited"}integrityCheckOnKeyAddition(){if(this.finished)throw"Adding values after finish is prohibited";if(this.stackPointers.length===0||this.stackPointers[this.stackPointers.length-1].isVector)throw"Adding key before starting a map is prohibited"}startVector(){this.stackPointers.push({stackPosition:this.stack.length,isVector:!0})}startMap(t=!1){this.stackPointers.push({stackPosition:this.stack.length,isVector:!1,presorted:t})}endVector(t){const e=this.stack.length-t.stackPosition,s=this.createVector(t.stackPosition,e,1);this.stack.splice(t.stackPosition,e),this.stack.push(s)}endMap(t){t.presorted||this.sort(t);let e="";for(let c=t.stackPosition;c<this.stack.length;c+=2)e+=`,${this.stack[c].offset}`;const s=this.stack.length-t.stackPosition>>1;this.dedupKeyVectors&&!Object.prototype.hasOwnProperty.call(this.keyVectorLookup,e)&&(this.keyVectorLookup[e]=this.createVector(t.stackPosition,s,2));const h=this.dedupKeyVectors?this.keyVectorLookup[e]:this.createVector(t.stackPosition,s,2),r=this.createVector(t.stackPosition+1,s,2,h);this.stack.splice(t.stackPosition,s<<1),this.stack.push(r)}sort(t){const e=this.view,s=this.stack;function h(f,u){if(f.type!==n.KEY||u.type!==n.KEY)throw`Stack values are not keys ${f} | ${u}. Check if you combined [addKey] with add... method calls properly.`;let o,T,I=0;do{if(o=e.getUint8(f.offset+I),T=e.getUint8(u.offset+I),T<o)return!0;if(o<T)return!1;I+=1}while(o!==0&&T!==0);return!1}function r(f,u,o){if(u===o)return;const T=f[u],I=f[u+1];f[u]=f[o],f[u+1]=f[o+1],f[o]=T,f[o+1]=I}function c(){for(let f=t.stackPosition;f<s.length;f+=2){let u=f;for(let o=f+2;o<s.length;o+=2)h(s[u],s[o])&&(u=o);u!==f&&r(s,u,f)}}function d(f,u){if(f.type!==n.KEY||u.type!==n.KEY)throw`Stack values are not keys ${f} | ${u}. Check if you combined [addKey] with add... method calls properly.`;if(f.offset===u.offset)return!1;let o,T,I=0;do{if(o=e.getUint8(f.offset+I),T=e.getUint8(u.offset+I),o<T)return!0;if(T<o)return!1;I+=1}while(o!==0&&T!==0);return!1}function a(f,u){if(f<u){const o=f+(u-f>>2)*2,T=s[o];let I=f,w=u;do{for(;d(s[I],T);)I+=2;for(;d(T,s[w]);)w-=2;I<=w&&(r(s,I,w),I+=2,w-=2)}while(I<=w);a(f,w),a(I,u)}}let O=!0;for(let f=t.stackPosition;f<this.stack.length-2;f+=2)if(h(this.stack[f],this.stack[f+2])){O=!1;break}O||(this.stack.length-t.stackPosition>40?a(t.stackPosition,this.stack.length-2):c())}end(){if(this.stackPointers.length<1)return;const t=this.stackPointers.pop();t.isVector?this.endVector(t):this.endMap(t)}createVector(t,e,s,h=null){let r=y(e),c=1;if(h!==null){const o=h.elementWidth(this.offset,0);o>r&&(r=o),c+=2}let d=n.KEY,a=h===null;for(let o=t;o<this.stack.length;o+=s){const T=this.stack[o].elementWidth(this.offset,o+c);T>r&&(r=T),o===t?(d=this.stack[o].type,a=a&&K(d)):d!==this.stack[o].type&&(a=!1)}const O=this.align(r),f=a&&A(d)&&e>=2&&e<=4;h!==null&&(this.writeStackValue(h,O),this.writeUInt(1<<h.width,O)),f||this.writeUInt(e,O);const u=this.offset;for(let o=t;o<this.stack.length;o+=s)this.writeStackValue(this.stack[o],O);if(!a)for(let o=t;o<this.stack.length;o+=s)this.writeUInt(this.stack[o].storedPackedType(),1);if(h!==null)return this.offsetStackValue(u,n.MAP,r);if(a){const o=$(d,f?e:0);return this.offsetStackValue(u,o,r)}return this.offsetStackValue(u,n.VECTOR,r)}nullStackValue(){return new b(this,n.NULL,l.WIDTH8)}boolStackValue(t){return new b(this,n.BOOL,l.WIDTH8,t)}intStackValue(t){return new b(this,n.INT,F(t),t)}uintStackValue(t){return new b(this,n.UINT,y(t),t)}floatStackValue(t){return new b(this,n.FLOAT,H(t),t)}offsetStackValue(t,e,s){return new b(this,e,s,null,t)}finishBuffer(){if(this.stack.length!==1)throw`Stack has to be exactly 1, but it is ${this.stack.length}. You have to end all started vectors and maps before calling [finish]`;const t=this.stack[0],e=this.align(t.elementWidth(this.offset,0));this.writeStackValue(t,e),this.writeUInt(t.storedPackedType(),1),this.writeUInt(e,1),this.finished=!0}add(t){if(this.integrityCheckOnValueAddition(),typeof t>"u")throw"You need to provide a value";if(t===null)this.stack.push(this.nullStackValue());else if(typeof t=="boolean")this.stack.push(this.boolStackValue(t));else if(typeof t=="bigint")this.stack.push(this.intStackValue(t));else if(typeof t=="number")Number.isInteger(t)?this.stack.push(this.intStackValue(t)):this.stack.push(this.floatStackValue(t));else if(ArrayBuffer.isView(t))this.writeBlob(t.buffer);else if(typeof t=="string"||t instanceof String)this.writeString(t);else if(Array.isArray(t)){this.startVector();for(let e=0;e<t.length;e++)this.add(t[e]);this.end()}else if(typeof t=="object"){const e=Object.getOwnPropertyNames(t).sort();this.startMap(!0);for(let s=0;s<e.length;s++){const h=e[s];this.addKey(h),this.add(t[h])}this.end()}else throw`Unexpected value input ${t}`}finish(){this.finished||this.finishBuffer();const t=this.buffer.slice(0,this.offset);return new Uint8Array(t)}isFinished(){return this.finished}addKey(t){this.integrityCheckOnKeyAddition(),this.writeKey(t)}addInt(t,e=!1,s=!1){if(this.integrityCheckOnValueAddition(),!e){this.stack.push(this.intStackValue(t));return}if(s&&Object.prototype.hasOwnProperty.call(this.indirectIntLookup,t)){this.stack.push(this.indirectIntLookup[t]);return}const h=this.intStackValue(t),r=this.align(h.width),c=this.computeOffset(r),d=this.offset;h.writeToBuffer(r);const a=this.offsetStackValue(d,n.INDIRECT_INT,h.width);this.stack.push(a),this.offset=c,s&&(this.indirectIntLookup[t]=a)}addUInt(t,e=!1,s=!1){if(this.integrityCheckOnValueAddition(),!e){this.stack.push(this.uintStackValue(t));return}if(s&&Object.prototype.hasOwnProperty.call(this.indirectUIntLookup,t)){this.stack.push(this.indirectUIntLookup[t]);return}const h=this.uintStackValue(t),r=this.align(h.width),c=this.computeOffset(r),d=this.offset;h.writeToBuffer(r);const a=this.offsetStackValue(d,n.INDIRECT_UINT,h.width);this.stack.push(a),this.offset=c,s&&(this.indirectUIntLookup[t]=a)}addFloat(t,e=!1,s=!1){if(this.integrityCheckOnValueAddition(),!e){this.stack.push(this.floatStackValue(t));return}if(s&&Object.prototype.hasOwnProperty.call(this.indirectFloatLookup,t)){this.stack.push(this.indirectFloatLookup[t]);return}const h=this.floatStackValue(t),r=this.align(h.width),c=this.computeOffset(r),d=this.offset;h.writeToBuffer(r);const a=this.offsetStackValue(d,n.INDIRECT_FLOAT,h.width);this.stack.push(a),this.offset=c,s&&(this.indirectFloatLookup[t]=a)}}function W(i,t,e){return e<2?e<1?i.getInt8(t):i.getInt16(t,!0):e<3?i.getInt32(t,!0):i.setBigInt64===void 0?BigInt(i.getUint32(t,!0))+(BigInt(i.getUint32(t+4,!0))<<BigInt(32)):i.getBigInt64(t,!0)}function k(i,t,e){return e<2?e<1?i.getUint8(t):i.getUint16(t,!0):e<3?i.getUint32(t,!0):i.getBigUint64===void 0?BigInt(i.getUint32(t,!0))+(BigInt(i.getUint32(t+4,!0))<<BigInt(32)):i.getBigUint64(t,!0)}function R(i,t,e){if(e<l.WIDTH32)throw"Bad width: "+e;return e===l.WIDTH32?i.getFloat32(t,!0):i.getFloat64(t,!0)}function g(i,t,e){const s=k(i,t,e);return t-s}function j(i,t,e,s,h,r){const c=U(i),d=g(t,e,s)-h*3,a=p(h),O=d-Number(k(t,d,a)),f=Number(k(t,d+h,a));let u=0,o=r-1;for(;u<=o;){const T=o+u>>1,I=G(c,T,t,O,f);if(I===0)return T;I<0?o=T-1:u=T+1}return null}function G(i,t,e,s,h){const r=s+t*h,c=r-Number(k(e,r,p(h)));for(let d=0;d<i.length;d++){const a=i[d]-e.getUint8(c+d);if(a!==0)return a}return e.getUint8(c+i.length)===0?0:-1}function v(i,t,e,s,h){const r=g(t,e,s)-h*3,c=p(h),d=r-Number(k(t,r,c)),a=Number(k(t,r+h,c)),O=d+i*a,f=O-Number(k(t,O,p(a)));let u=0;for(;t.getUint8(f+u)!==0;)u++;return m(new Uint8Array(t.buffer,f,u))}function q(i){const t=i.byteLength;if(t<3)throw"Buffer needs to be bigger than 3";const e=new DataView(i),s=e.getUint8(t-1),h=e.getUint8(t-2),r=p(s),c=t-s-2;return new N(e,c,r,h,"/")}function C(i,t,e,s,h,r,c,d){const a=g(e,s,h),O=a+i*r,f=e.getUint8(a+c*r+i);return new N(e,O,p(r),f,`${d}/${t}`)}class N{constructor(t,e,s,h,r){this.dataView=t,this.offset=e,this.parentWidth=s,this.packedType=h,this.path=r,this._length=-1,this.byteWidth=1<<(h&3),this.valueType=h>>2}isNull(){return this.valueType===n.NULL}isNumber(){return A(this.valueType)||P(this.valueType)}isFloat(){return n.FLOAT===this.valueType||n.INDIRECT_FLOAT===this.valueType}isInt(){return this.isNumber()&&!this.isFloat()}isString(){return n.STRING===this.valueType||n.KEY===this.valueType}isBool(){return n.BOOL===this.valueType}isBlob(){return n.BLOB===this.valueType}isVector(){return V(this.valueType)}isMap(){return n.MAP===this.valueType}boolValue(){return this.isBool()?W(this.dataView,this.offset,this.parentWidth)>0:null}intValue(){return this.valueType===n.INT?W(this.dataView,this.offset,this.parentWidth):this.valueType===n.UINT?k(this.dataView,this.offset,this.parentWidth):this.valueType===n.INDIRECT_INT?W(this.dataView,g(this.dataView,this.offset,this.parentWidth),p(this.byteWidth)):this.valueType===n.INDIRECT_UINT?k(this.dataView,g(this.dataView,this.offset,this.parentWidth),p(this.byteWidth)):null}floatValue(){return this.valueType===n.FLOAT?R(this.dataView,this.offset,this.parentWidth):this.valueType===n.INDIRECT_FLOAT?R(this.dataView,g(this.dataView,this.offset,this.parentWidth),p(this.byteWidth)):null}numericValue(){return this.floatValue()||this.intValue()}stringValue(){if(this.valueType===n.STRING||this.valueType===n.KEY){const t=g(this.dataView,this.offset,this.parentWidth);return m(new Uint8Array(this.dataView.buffer,t,this.length()))}return null}blobValue(){if(this.isBlob()){const t=g(this.dataView,this.offset,this.parentWidth);return new Uint8Array(this.dataView.buffer,t,this.length())}return null}get(t){const e=this.length();if(Number.isInteger(t)&&V(this.valueType)){if(t>=e||t<0)throw`Key: [${t}] is not applicable on ${this.path} of ${this.valueType} length: ${e}`;const s=g(this.dataView,this.offset,this.parentWidth),h=s+t*this.byteWidth;let r=this.dataView.getUint8(s+e*this.byteWidth+t);if(S(this.valueType)){const c=x(this.valueType);r=L(c,l.WIDTH8)}else if(_(this.valueType)){const c=Y(this.valueType);r=L(c,l.WIDTH8)}return new N(this.dataView,h,p(this.byteWidth),r,`${this.path}[${t}]`)}if(typeof t=="string"){const s=j(t,this.dataView,this.offset,this.parentWidth,this.byteWidth,e);if(s!==null)return C(s,t,this.dataView,this.offset,this.parentWidth,this.byteWidth,e,this.path)}throw`Key [${t}] is not applicable on ${this.path} of ${this.valueType}`}length(){let t;if(this._length>-1)return this._length;if(_(this.valueType))this._length=M(this.valueType);else if(this.valueType===n.BLOB||this.valueType===n.MAP||V(this.valueType))this._length=k(this.dataView,g(this.dataView,this.offset,this.parentWidth)-this.byteWidth,p(this.byteWidth));else if(this.valueType===n.NULL)this._length=0;else if(this.valueType===n.STRING){const e=g(this.dataView,this.offset,this.parentWidth);let s=this.byteWidth;for(t=k(this.dataView,e-s,p(this.byteWidth));this.dataView.getInt8(e+t)!==0;)s<<=1,t=k(this.dataView,e-s,p(this.byteWidth));this._length=t}else if(this.valueType===n.KEY){const e=g(this.dataView,this.offset,this.parentWidth);for(t=1;this.dataView.getInt8(e+t)!==0;)t++;this._length=t}else this._length=1;return Number(this._length)}toObject(){const t=this.length();if(this.isVector()){const e=[];for(let s=0;s<t;s++)e.push(this.get(s).toObject());return e}if(this.isMap()){const e={};for(let s=0;s<t;s++){const h=v(s,this.dataView,this.offset,this.parentWidth,this.byteWidth);e[h]=C(s,h,this.dataView,this.offset,this.parentWidth,this.byteWidth,t,this.path).toObject()}return e}return this.isNull()?null:this.isBool()?this.boolValue():this.isNumber()?this.numericValue():this.blobValue()||this.stringValue()}}export{z as B,q as t};
