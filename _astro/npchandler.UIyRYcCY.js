import{c as B}from"./@supabase.Bwp_VmKO.js";import{D as M}from"./dexie.Db70IFYj.js";import{p as x,a as R}from"./@nanostores.4Ikc6yb_.js";import{t as W,m as z,a as L}from"./nanostores.Bo9-_MAV.js";import{a as m}from"./axios.Bw-gCGc_.js";import{R as H,r as v,j as N}from"./react.C2V1wh_4.js";const T={hcaptcha:"5ba581fa-b6fc-4bb0-8222-02fcd6a59e35",hcaptcha_api:"https://js.hcaptcha.com/1/api.js",api:"https://supabase.kbve.com",anonKey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ewogICJyb2xlIjogImFub24iLAogICJpc3MiOiAic3VwYWJhc2UiLAogICJpYXQiOiAxNzI0NTM2ODAwLAogICJleHAiOiAxODgyMzAzMjAwCn0._fmEmblm0afeLoPXxt8wP2mYpa9gzU-ufx3v8oRTFGg"},F={_state:{...T},get(){return{...this._state}},set(c){this._state={...this._state,...c}},reset(){this._state={...T}},toString(){return JSON.stringify(this._state,null,2)},getKey(c){return this._state[c]}},C="0123456789ABCDEFGHJKMNPQRSTVWXYZ";function q(c,t,e){for(;c.length<t;)c=e+c;return c}function G(){const c=Math.floor(Math.random()*C.length);return C.charAt(c)}function V(c){let t="";for(let e=0;e<c;e++)t+=G();return t}function Y(c,t){let e="";for(let a=t-1;a>=0;a--){const r=c%C.length;e=C.charAt(r)+e,c=Math.floor(c/C.length)}return q(e,t,C[0])}function A(){const c=Date.now(),t=Y(c,10),e=V(16),a=t+e;return{toString:()=>a,valueOf:()=>a}}const X={id:"",title:"",description:"",journals:[],isComplete:!1,reward:""},Q={backpack:[],equipment:{head:null,body:null,legs:null,feet:null,hands:null,weapon:null,shield:null,accessory:null}},J={},Z={inCombat:!1,isDead:!1,isResting:!1,activeBoosts:{}},K={username:"Guest",health:"100",mana:"100",energy:"100",maxHealth:"100",maxMana:"100",maxEnergy:"100",armour:"0",agility:"0",strength:"0",intelligence:"0",experience:"0",reputation:"0",faith:"0"},tt={stats:K,inventory:Q,state:Z},et={tooltipItem:{id:null,position:{x:0,y:0}},submenuItem:{id:null,position:{x:0,y:0}},tooltipNPC:{id:null,position:{x:0,y:0}},isStatsMenuCollapsed:!1,isSettingsMenuCollapsed:!1,debugMode:!1,textSpeed:40},at={gamemode:"Idle",action:{type:"ROLL_DICE",diceValues:[],isRolling:!1},textures:{side1:"",side2:"",side3:"",side4:"",side5:"",side6:""}};function b(c,t){return x(c,t,{encode(e){return JSON.stringify(e)},decode(e){try{return JSON.parse(e)}catch{return t}}})}b("playerData",tt);b("quest",X);b("items",J);b("notifications",[]);b("itemDB",J);const I=b("settings",et);b("minigameState",at);const st=c=>I.get()[c],O=(c,t)=>{W(async()=>{const e=I.get();I.set({...e,[c]:t})})},rt=()=>{O("debugMode",!0)},ot=()=>{O("debugMode",!1)},k=()=>st("debugMode"),D=c=>typeof c=="string"?c:JSON.stringify(c,null,2),it=c=>{k()&&console.log(`[DEBUG] ${D(c)}`)},nt=c=>{k()&&console.warn(`[DEBUG] ${D(c)}`)},lt=(c,t)=>{k()&&(t instanceof Error?console.error(`[DEBUG] ${D(c)} - Error: ${t.message}
${t.stack}`):console.error(`[DEBUG] ${D(c)}`))},i={enable:rt,disable:ot,isEnabled:k,log:it,warn:nt,error:lt};class ct{constructor(){this.events={},this.lastEmitted=new Map}on(t,e){this.events[t]||(this.events[t]=[]),this.events[t]?.push(e)}off(t,e){this.events[t]&&(this.events[t]=this.events[t]?.filter(a=>a!==e))}emit(t,e,a=0,r){const s=Date.now(),o=this.lastEmitted.get(t)||0;if(s-o>=a){if(!this.events[t])return;this.events[t]?.forEach(n=>n(e)),r&&i.isEnabled()&&i.log(`Event: ${String(t)} - Message: ${r}`),i.isEnabled()&&i.log(`Event Data: ${String(t)} - Data: ${e?JSON.stringify(e):"No data"}`),this.lastEmitted.set(t,s)}}}const y=new ct,E={id:"",email:"",updatedAt:new Date,fullName:"Guest",username:"Guest"},$=z(E),U=L(!1),P=L(null);class _ extends M{constructor(){super("KilobaseDB"),this.supabase=null,this.profileKey="userProfile",this.handleUserRedirect=t=>{if(!t||!t.location)return;const{location:e,timer:a=0,replace:r=!1}=t;console.log(`Redirecting user to: ${e} in ${a}ms`),setTimeout(()=>{this.cleanupEventListeners(),r?window.location.replace(e):window.location.href=e},a)},this.version(1).stores({keyValueStore:"key",profiles:"&id, email",errorLogs:"++id, actionId, message, timestamp",actionULID:"&id, action, timestamp, status, errorId"}),this.profiles=this.table("profiles"),this.errorLogs=this.table("errorLogs"),this.actionULID=this.table("actionULID"),this.supabase=this.initializeSupabaseClient(),this.initializeEventListeners()}initializeEventListeners(){y.on("redirectUser",this.handleUserRedirect)}cleanupEventListeners(){y.off("redirectUser",this.handleUserRedirect)}initializeSupabaseClient(){if(typeof window<"u"&&window.supabase&&(console.log("Using global Supabase client instance:",window.supabase),this.supabase=window.supabase),!this.supabase)try{this.supabase=B(F.get().api,F.get().anonKey),console.log("Supabase client instance created:",this.supabase),typeof window<"u"&&(window.supabase=this.supabase)}catch(t){throw console.error("Error creating Supabase client:",t),t}return this.supabase}getSupabaseClient(){return this.supabase}async registerUser(t,e,a,r,s,o){const n=this.getSupabaseClient();if(!n)return null;try{if(e!==a)return await this.handleAuthError({message:"Password and confirm password do not match."},r),null;const{data:l,error:d}=await n.auth.signUp({email:t,password:e,options:{captchaToken:o,data:{username:s,full_name:s}}});if(d)return await this.handleAuthError(d,r),null;if(l?.user){const u={id:l.user.id,email:l.user.email||"",username:l.user.user_metadata?.username||void 0,fullName:l.user.user_metadata?.full_name||void 0,updatedAt:new Date(l.user.updated_at||Date.now())};return await this.saveProfile(u),await this.updateActionStatus(r,"completed"),u}}catch(l){return await this.handleAuthError(l,r),null}return null}async createActionULID(t){const e=A().toString(),a={id:e,action:t,timestamp:new Date,status:"pending"};return await this.actionULID.add(a),e}async handleAuthError(t,e){let a="An unknown error occurred. Please try again.",r={...t},s="";t?.message&&(a=t.message),t?.code&&(s+=`Error Code: ${t.code}. `),t?.status&&(s+=`Status: ${t.status}. `),t?.supabaseCode&&(s+=`Supabase Code: ${t.supabaseCode}. `),t?.details&&(s+=`Details: ${JSON.stringify(t.details)}. `),s&&(a=`${a} (${s.trim()})`);const o={invalid_grant:"Invalid credentials provided.",invalid_request:"The request is missing a required parameter.",expired_token:"The token has expired. Please log in again.",invalid_token:"The token provided is invalid. Please try again.",email_already_exists:"The email address is already in use.",user_already_exists:"A user with this identifier already exists. Please log in instead.",invalid_password:"The password provided is incorrect."};switch(t?.code&&o[t.code]&&(a=o[t.code]),t?.status){case 400:a="Bad request. Please check the input fields.";break;case 401:a="Unauthorized. Please check your credentials.";break;case 403:a="Forbidden. You do not have permission to perform this action.";break;case 404:a="Resource not found. Please try again.";break;case 422:a="Unprocessable entity. Please check the provided data.";break;case 500:a="Internal server error. Please try again later.";break;default:a=a||"An unknown error occurred. Please try again.";break}throw await this.logError(a,{...r,supabaseCode:t?.code,statusCode:t?.status},e),console.error("Authentication Error:",a),new Error(a)}async saveProfile(t){try{await this.table("keyValueStore").put({key:this.profileKey,value:t}),t.username&&P.set(t.username),$.set(t),console.log("Profile saved locally:",t)}catch(e){console.error("Failed to save profile locally:",e)}}async loadProfile(){try{const t=await this.table("keyValueStore").get(this.profileKey);if(t?.value){$.set(t.value),console.log("Profile loaded from local storage:",t.value);return}await this.loadProfileFromSupabase()}catch(t){console.error("Failed to load profile:",t)}}async loadProfileFromSupabase(){const t=this.getSupabaseClient();if(t)try{U.set(!0);const{data:{user:e},error:a}=await t.auth.getUser();if(a){console.error("Failed to get authenticated user from Supabase:",a),await this.logError("Failed to get authenticated user from Supabase",a);return}if(!e){console.warn("No authenticated user found");return}const{data:r,error:s}=await t.from("user_profiles").select("id, username, updated_at").eq("id",e.id).single();if(s){console.error("Failed to load user profile from Supabase:",s),await this.logError("Failed to load user profile from Supabase",s);return}if(r){const o={id:r.id,email:e.email||"",username:r.username||void 0,fullName:e.user_metadata?.full_name||void 0,updatedAt:new Date(r.updated_at)};await this.saveProfile(o),console.log("Profile loaded and saved from Supabase:",o)}}catch(e){console.error("An unexpected error occurred while loading the profile:",e),await this.logError("An unexpected error occurred while loading the profile",e)}finally{U.set(!1)}}async removeProfile(){const t=this.getSupabaseClient();if(t)try{const e=$.get();await this.table("keyValueStore").delete(this.profileKey),await this.profiles.delete(e.id),$.set(E),console.log(`Profile ${e.id} removed locally and store reset`),P.set(null);const{error:a}=await t.auth.signOut();a?(await this.logError("Failed to log out user from Supabase",a),console.error("Failed to log out user from Supabase:",a)):console.log("User logged out successfully from Supabase.")}catch(e){await this.logError("Failed to remove profile",e),console.error("Failed to remove profile:",e)}}async getProfile(){const t=$.get();if(t.id!=="")return t;try{const e=await this.table("keyValueStore").get(this.profileKey);if(e?.value){const a=e.value;return $.set(a),a}}catch(e){console.error("Failed to get profile from Dexie:",e)}return E}async createAction(t){const a={id:A().toString(),action:t,timestamp:new Date,status:"pending"};return await this.actionULID.add(a),a}async updateActionStatus(t,e,a){await this.actionULID.update(t,{status:e,errorId:a})}async logError(t,e,a){try{let r=null;if(a&&(r=await this.errorLogs.where("actionId").equals(a).first()),r){console.warn(`Error already exists for actionId: ${a}. Skipping new error log.`);return}const s={message:t,details:e,actionId:a,timestamp:new Date},o=await this.errorLogs.add(s);console.log("Error logged to Dexie:",s),a&&await this.updateActionStatus(a,"failed",o)}catch(r){console.error("Failed to log error:",r)}}async extractAuthErrorDetails(t){if(!t)return"Unknown error occurred. No error details available.";let e=t.message||"Unknown error occurred",a="";return t?.code&&(a+=`Error Code: ${t.code}. `),t?.status&&(a+=`Status: ${t.status}. `),t?.supabaseCode&&(a+=`Supabase Code: ${t.supabaseCode}. `),t?.details&&(a+=`Details: ${JSON.stringify(t.details)}. `),a&&(e=`${e} (${a.trim()})`),e}async getDetailedErrorByActionId(t){try{const e=await this.errorLogs.where("actionId").equals(t).last();return e?this.extractAuthErrorDetails(e):null}catch(e){return console.error(`Failed to retrieve detailed error for actionId: ${t}`,e),null}}async getErrorByActionId(t){try{const e=await this.errorLogs.where("actionId").equals(t).last();return e?e.message:null}catch(e){return console.error(`Failed to retrieve error for actionId: ${t}`,e),null}}async loginUser(t,e,a,r){const s=this.getSupabaseClient();if(!s)return null;try{const{data:o,error:n}=await s.auth.signInWithPassword({email:t,password:e,options:{captchaToken:r}});if(n)return await this.handleAuthError(n,a),null;if(o?.user){const l={id:o.user.id,email:o.user.email||"",username:o.user.user_metadata?.username||void 0,fullName:o.user.user_metadata?.full_name||void 0,updatedAt:new Date(o.user.updated_at||Date.now())};return await this.saveProfile(l),console.log("User logged in successfully:",l),l}}catch(o){return await this.handleAuthError(o,a),null}return null}async getSession(){const t=this.getSupabaseClient();if(!t)return null;try{const{data:e,error:a}=await t.auth.getSession();return a?(console.error("Failed to retrieve session:",a),null):e.session||null}catch(e){return console.error("Error getting session:",e),null}}async getUsername(){if(P.get())return P.get();try{const t=await this.table("keyValueStore").get(this.profileKey);if(t?.value?.username)return P.set(t.value.username),t.value.username}catch(t){console.error("Failed to get username from Dexie:",t)}return null}static createPersistentAtom(t,e){return x(t,e,{encode:JSON.stringify,decode:JSON.parse})}createPersistentMap(t,e){return R(t,e,{encode:JSON.stringify,decode:JSON.parse})}updateAtomField(t,e,a){t.set({...t.get(),[e]:a})}updateMapField(t,e,a){const s={...t.get(),[e]:a};t.set(s)}removeMapField(t,e){const a=t.get(),{[e]:r,...s}=a;t.set(s)}removeAtomField(t,e){const a=t.get(),{[e]:r,...s}=a;t.set(s)}resetState(t,e){t.set(e)}getPersistentAtom(t){return t.get()}}_.createPersistentAtom("atlas",{plugin:[]});const Nt=new _;class dt extends M{constructor(){super("MapDatabase"),this.chunkSize=10,this.tileWidth=32,this.tileHeight=32,this.chunkWidth=this.chunkSize*this.tileWidth,this.chunkHeight=this.chunkSize*this.tileHeight,this.scale=1,this.displayedChunks=new Set,this.version(1).stores({maps:"tilemapKey",jsonFiles:"tilemapKey",tilesetImages:"tilemapKey",chunks:"[tilemapKey+chunkX+chunkY]",tileJsonData:"tilemapKey"}),this.maps=this.table("maps"),this.jsonFiles=this.table("jsonFiles"),this.tilesetImages=this.table("tilesetImages"),this.chunks=this.table("chunks"),this.tileJsonData=this.table("tileJsonData")}resetMapSettings(){this.displayedChunks.clear()}async initializeMapDatabase(){const t="/api/mapdb.json",e="https://kbve.com/api/mapdb.json";let a;try{a=(await m.get(t)).data,i.log(`Map database loaded from ${t}`)}catch{i.warn(`Failed to load map database from ${t}, trying fallback URL.`);try{a=(await m.get(e)).data,i.log(`Map database loaded from ${e}`)}catch{i.error(`Failed to load map database from both ${t} and ${e}`);return}}if(a&&a.key){for(const r in a.key)if(Object.prototype.hasOwnProperty.call(a.key,r)){const s=a.key[r];await this.addMap(s),await this.addJsonData(r,s.jsonDataUrl);const o=await this.fetchTilesetImage(s.tilesetImageUrl);o&&await this.addTilesetImage(r,o)}i.log("Map database initialized and data loaded.")}else i.error("Invalid map database format.")}async addMap(t){await this.maps.put(t)}async getMap(t){return await this.maps.get(t)}async addJsonData(t,e){await this.jsonFiles.put({tilemapKey:t,jsonData:e})}async getJsonData(t){return(await this.jsonFiles.get(t))?.jsonData}async addTilesetImage(t,e){await this.tilesetImages.put({tilemapKey:t,imageData:e})}async getTilesetImage(t){return(await this.tilesetImages.get(t))?.imageData}async getBounds(t){return(await this.maps.get(t))?.bounds}async getNpcsFromTilesetKey(t){const e=await ut.getMap(t);if(!e){i.error(`No map data found for tilesetKey: ${t}`);return}return e.npcs}async fetchMapData(t){try{return(await m.get(t)).data}catch(e){i.error(`Failed to fetch map data from ${t}:`,e);return}}async fetchJsonData(t){try{return(await m.get(t)).data}catch(e){i.error(`Failed to fetch JSON data from ${t}:`,e);return}}async fetchTilesetImage(t){try{return(await m.get(t,{responseType:"blob"})).data}catch(e){i.error(`Failed to fetch tileset image from ${t}:`,e);return}}async initializeMap(t,e,a,r){try{const s=await this.fetchMapData(e);if(s){await this.addMap(s);const o=await this.fetchJsonData(a);o&&await this.addJsonData(t,o);const n=await this.fetchTilesetImage(r);n&&await this.addTilesetImage(t,n)}}catch(s){i.error("Failed to initialize map database:",s)}}async loadMapIntoScene(t,e){const a=await this.getMap(e);if(!a){i.error(`Map with key ${e} not found`);return}const r=await this.getJsonData(e);if(!r){i.error(`JSON data for map ${e} not found`);return}const s=await this.getTilesetImage(e);if(!s){i.error(`Tileset image for map ${e} not found`);return}let o=null;try{o=URL.createObjectURL(s)}catch(n){i.error(`Failed to create object URL for tileset image: ${n}`);return}if(!o){i.error(`Tileset image URL for map ${e} could not be created.`);return}t.load.tilemapTiledJSON(e,r),t.load.image(a.tilesetKey,o),t.load.once("complete",()=>{const n=t.make.tilemap({key:e}),l=n.addTilesetImage(a.tilesetName,a.tilesetKey);if(l)for(let d=0;d<n.layers.length;d++){const u=n.createLayer(d,l,0,0);u?u.scale=a.scale:i.error(`Layer ${d} could not be created.`)}else i.error(`Tileset ${a.tilesetName} could not be created.`)}),t.load.start()}async loadMap(t,e){const a=await this.getMap(e);if(!a)throw new Error(`Map with key ${e} not found`);const r=await this.getJsonData(e);if(!r)throw new Error(`JSON data for map ${e} not found`);const s=await this.getTilesetImage(e);if(!s)throw new Error(`Tileset image for map ${e} not found`);let o=null;try{o=URL.createObjectURL(s)}catch(n){throw new Error(`Failed to create object URL for tileset image: ${n}`)}if(!o)throw new Error(`Tileset image URL for map ${e} could not be created.`);return t.load.tilemapTiledJSON(e,r),t.load.image(a.tilesetKey,o),new Promise(n=>{t.load.once("complete",()=>{const l=t.make.tilemap({key:e});if(l.addTilesetImage(a.tilesetName,a.tilesetKey)){for(let u=0;u<l.layers.length;u++){const h=l.createLayer(u,a.tilesetName,0,0);h?h.scale=a.scale:console.error(`Layer ${u} could not be created.`)}n(l)}else console.error(`Tileset ${a.tilesetName} could not be created.`),n(null)}),t.load.start()})}async prepareMapLoad(t){if(!await this.getMap(t))throw new Error(`Map with key ${t} not found`);if(!await this.getJsonData(t))throw new Error(`JSON data for map ${t} not found`);const r=await this.getTilesetImage(t);if(!r)throw new Error(`Tileset image for map ${t} not found`);let s=null;try{s=URL.createObjectURL(r)}catch(o){throw new Error(`Failed to create object URL for tileset image: ${o}`)}if(!s)throw new Error(`Tileset image URL for map ${t} could not be created.`);await this.chunkMap(t)}async getParsedJsonData(t){const e=await this.tileJsonData.get(t);if(e)return e.jsonContent;const a=await this.jsonFiles.get(t);if(!a)return i.error(`JSON file path for ${t} not found`),null;try{const s=(await m.get(a.jsonData)).data;return await this.tileJsonData.put({tilemapKey:t,jsonContent:s}),s}catch(r){return i.error(`Failed to fetch or parse JSON data for ${t}:`,r),null}}async addChunk(t,e,a,r,s){i.log(`Adding chunk for (${e}, ${a}) of ${t}`),i.log(`Chunk data: ${r}`),await this.chunks.put({tilemapKey:t,chunkX:e,chunkY:a,jsonData:r,imageData:s})}async getChunk(t,e,a){const r=await this.chunks.get([t,e,a]);return i.log(`Retrieved chunk for (${e}, ${a}) of ${t}: ${r}`),r}async removeChunk(t,e,a){await this.chunks.delete([t,e,a])}async removeChunks(t,e){const a=e.map(({chunkX:r,chunkY:s})=>this.removeChunk(t,r,s));await Promise.all(a)}async extractChunkJsonData(t,e,a,r){const s=await this.getParsedJsonData(t);if(!s)return i.error(`Parsed JSON data for map ${t} not found`),null;const o=e*r,n=a*r,l=Math.min(o+r,s.width),d=Math.min(n+r,s.height),u=[];for(let h=n;h<d;h++){const f=s.layers[0].data.slice(h*s.width+o,h*s.width+l);u.push(...f)}return{...s,width:l-o,height:d-n,layers:[{...s.layers[0],data:u}]}}async getMapDimensions(t){const e=await this.getParsedJsonData(t);if(!e){i.error(`Failed to retrieve JSON data for ${t}`);return}const a=e.width,r=e.height;if(a>0&&r>0)return{width:a,height:r};i.error(`Invalid JSON data for map ${t}`)}async chunkMap(t){const e=await this.getMapDimensions(t);if(!e){i.error(`Failed to retrieve dimensions for map ${t}`);return}const{width:a,height:r}=e,s=10,o=Math.ceil(a/s),n=Math.ceil(r/s);i.log(`Starting chunkMap for ${t}`);for(let l=0;l<o;l++)for(let d=0;d<n;d++){const u=await this.extractChunkJsonData(t,l,d,s);if(!u){i.error(`Failed to extract JSON data for chunk (${l}, ${d}) of ${t}`);continue}i.log(`Storing chunk (${l}, ${d}) for ${t}`),await this.addChunk(t,l,d,u)}i.log(`Finished chunkMap for ${t}`)}async loadChunkIntoScene(t,e,a,r){const s=await this.getChunk(e,a,r);if(!s){i.error(`Chunk data for (${a}, ${r}) not found`);return}const o=`${e}_${a}_${r}`;if(!await this.getMap(e)){i.error(`Map data not found for ${e}`);return}const l=s.jsonData.tilesets[0].name;if(!t.textures.exists(l)){const h=await this.getTilesetImage(e);if(h){const f=URL.createObjectURL(h);t.load.image(l,f),await new Promise(g=>t.load.once("complete",g)),t.load.start()}else{i.error(`Failed to load tileset image for ${l}`);return}}t.load.tilemapTiledJSON(o,s.jsonData),await new Promise(h=>t.load.once("complete",h)),t.load.start();const d=t.make.tilemap({key:o}),u=d.addTilesetImage(l);u?d.layers.forEach((h,f)=>{const g=d.createLayer(f,u,0,0);g?(g.setScale(this.scale),i.log(`Layer ${f} created for chunk (${a}, ${r}) with tileset ${l}.`)):i.error(`Layer ${f} could not be created for chunk (${a}, ${r}).`)}):i.error(`Tileset ${l} could not be added to tilemap.`)}removeChunkFromScene(t,e,a,r){const s=`${e}_${a}_${r}`,o=t.make.tilemap({key:s});o&&o.destroy(),t.cache.tilemap.remove(s)}async updateVisibleChunks(t,e,a,r,s){if(!await this.getMap(e)){console.error(`Map data for ${e} not found`);return}const n=this.tileWidth,l=this.tileHeight,d=this.chunkSize,u=Math.floor(a/(d*n)),h=Math.floor(r/(d*l)),f=new Set;for(let g=-s;g<=s;g++)for(let p=-s;p<=s;p++){const w=u+g,S=h+p,j=`${w},${S}`;w>=0&&S>=0&&(await this.loadChunkIntoScene(t,e,w,S),f.add(j))}for(const g of this.displayedChunks)if(!f.has(g)){const[p,w]=g.split(",").map(Number);this.removeChunkFromScene(t,e,p,w)}this.displayedChunks=f}async loadNewMap(t,e,a,r){i.log(`Loading map with key: ${e}`),this.resetMapSettings();const s=await this.getMap(e);if(!s)return i.error(`Map data not found for ${e}`),null;const o=Math.floor(a/(this.chunkWidth||1)),n=Math.floor(r/(this.chunkHeight||1)),l=await this.getChunk(e,o,n);if(!l)return i.error(`Chunk (${o}, ${n}) not found for ${e}`),null;const d=s.tilesetKey;if(!t.textures.exists(d)){const g=await this.getTilesetImage(e);if(g){const p=URL.createObjectURL(g);t.load.image(d,p),await new Promise(w=>{t.load.once("complete",w),t.load.start()})}else return i.error(`Failed to load tileset image for ${d}`),null}const u=`${e}_${o}_${n}`;t.load.tilemapTiledJSON(u,l.jsonData),await new Promise(g=>t.load.once("complete",g)),t.load.start();const h=t.make.tilemap({key:u});if(!h)return i.error(`Tilemap could not be created for chunk (${o}, ${n})`),null;const f=h.addTilesetImage(s.tilesetName,d);if(!f)return i.error(`Tileset ${d} could not be added to tilemap.`),null;for(let g=0;g<h.layers.length;g++){const p=h.createLayer(g,f,0,0);p?(p.setScale(s.scale||this.scale),i.log(`Layer ${g} created for initial chunk.`)):i.error(`Layer ${g} could not be created.`)}return h}}const ut=new dt,ht=({text:c,speed:t=80,onComplete:e})=>{const[a,r]=v.useState([]),s=v.useRef([]);return v.useEffect(()=>{let o,n=0;const l=c.split(/(<\/?span[^>]*>)/g).filter(Boolean),d=[];l.forEach((h,f)=>{if(h.startsWith("<span")||h.startsWith("</span")){const g=h.match(/<span class="([^"]*)">/);if(g){const p=g[1];d.push(N.jsx("span",{className:p},`span-${f}`))}else d.push(N.jsx("span",{},`span-${f}`))}else h.split("").forEach((g,p)=>{d.push(N.jsx("span",{children:g},`char-${f}-${p}`))})}),n=0;const u=()=>{n<d.length?(s.current=[...s.current,d[n]],r([...s.current]),n++,o=window.setTimeout(u,t)):e&&e()};return s.current=[],r([]),u(),()=>{window.clearTimeout(o)}},[c,t,e]),N.jsx("div",{children:a})};H.memo(ht);class gt extends M{constructor(){super("NPCDatabase"),this.version(3).stores({npcs:"id,name",sprites:"id",avatars:"id",dialogues:"id"}),this.npcs=this.table("npcs"),this.sprites=this.table("sprites"),this.avatars=this.table("avatars"),this.dialogues=this.table("dialogues")}async addNPC(t){await this.npcs.put(t)}async getNPC(t){return await this.npcs.get(t)}async getNPCByName(t){return await this.npcs.where("name").equals(t).first()}async getAllNPCs(){return await this.npcs.toArray()}async exportNPCs(){const t=await this.getAllNPCs();return JSON.stringify(t,null,2)}async importNPCs(t){const e=JSON.parse(t);await this.npcs.bulkPut(e)}async fetchNPCData(t){try{return(await m.get(t)).data}catch(e){i.error(`Failed to fetch NPC data from ${t}:`,e);return}}async addSprite(t){await this.sprites.put(t)}async getSprite(t){return await this.sprites.get(t)}async getAllSprites(){return await this.sprites.toArray()}async addAvatar(t){await this.avatars.put(t)}async getAvatar(t){return await this.avatars.get(t)}async getAllAvatars(){return await this.avatars.toArray()}async urlToBlob(t){try{return(await m.get(t,{responseType:"blob"})).data}catch(e){i.error(`Failed to fetch blob from ${t}:`,e);return}}async addNewSprite(t,e){const a=await this.urlToBlob(t);if(a){const r={...e,spriteData:a};return await this.addSprite(r),r.id}}async addNewNPC(t,e,a){const r={...t,spriteImageId:e,avatarImageId:a};await this.addNPC(r)}async addNewAvatar(t,e){const a=await this.urlToBlob(t);if(a){const r={...e,avatarData:a};return await this.addAvatar(r),r.id}}async fetchAvatars(t){try{const a=(await m.get(t)).data.key;for(const r in a){const s=a[r];let o=await this.urlToBlob(s.avatarLocation);if(o||(o=await this.urlToBlob(`https://kbve.com${s.avatarLocation}`)),o){const n={id:s.id,avatarName:s.avatarName,avatarLocation:s.avatarLocation,avatarData:o,slug:s.slug};await this.addAvatar(n)}}}catch(e){i.error(`Failed to fetch avatars from ${t}:`,e)}}async fetchSprites(t){try{const a=(await m.get(t)).data.key;for(const r in a){const s=a[r];let o=await this.urlToBlob(s.assetLocation);if(o||(o=await this.urlToBlob(`https://kbve.com${s.assetLocation}`)),o){const n={id:s.id,spriteName:s.spriteName,assetLocation:s.assetLocation,frameWidth:s.frameWidth,frameHeight:s.frameHeight,scale:s.scale,slug:s.slug,spriteData:o};await this.addSprite(n)}}}catch(e){i.error(`Failed to fetch sprites from ${t}:`,e)}}async fetchNPCs(t){try{const a=(await m.get(t)).data.key;for(const r in a){const s=a[r],o={id:s.id,name:s.name,spriteKey:s.spriteKey,walkingAnimationMapping:s.walkingAnimationMapping,startPosition:s.startPosition,speed:s.speed,scale:s.scale,slug:s.slug,actions:s.actions,effects:s.effects,stats:s.stats,spriteImageId:s.spriteImageId,avatarImageId:s.avatarImageId,dialogues:s.dialogues||[]};await this.addNPC(o)}}catch(e){i.error(`Failed to fetch NPCs from ${t}:`,e)}}async initializeDatabase(t="https://kbve.com"){await this.fetchAvatars(`${t}/api/avatardb.json`),await this.fetchSprites(`${t}/api/spritedb.json`),await this.fetchNPCs(`${t}/api/npcdb.json`),await this.fetchDialogues(`${t}/api/dialogue.json`)}async loadNPC(t,e,a,r){try{i.log(`Loading NPC with name: ${e}`);const s=await this.getNPCByName(e);if(!s)throw new Error(`NPC with name ${e} not found`);i.log(`NPC Data: ${JSON.stringify(s)}`),await this.loadCharacter(t,s.id,a,r)}catch(s){s instanceof Error?i.error(`Failed to load NPC: ${s.message}`):i.error("Failed to load NPC:",s)}}async loadCharacter(t,e,a,r){try{i.log(`Loading NPC with ID: ${e}`);const s=await this.getNPC(e);if(!s)throw new Error(`NPC with ID ${e} not found`);i.log(`NPC Data: ${JSON.stringify(s)}`);const o=s.spriteKey;if(t.textures.exists(o))i.log(`Texture with key ${o} already loaded.`),this.addNPCToScene(t,s,a,r);else{i.log(`Texture with key ${o} not found, attempting to load.`);const n=await this.getSprite(s.spriteImageId);if(n&&n.spriteData){i.log(`Sprite Data: ${JSON.stringify(n)}`);const l=URL.createObjectURL(n.spriteData);t.load.spritesheet(o,l,{frameWidth:n.frameWidth,frameHeight:n.frameHeight}),t.load.once("complete",()=>{i.log(`Texture ${o} loaded successfully.`),this.addNPCToScene(t,s,a,r)}),t.load.start()}else throw new Error(`Sprite with ID ${s.spriteImageId} not found`)}}catch(s){s instanceof Error?i.error(`Failed to load NPC: ${s.message}`):i.error("Failed to load NPC:",s)}}addNPCToScene(t,e,a,r){try{i.log(`Adding NPC to scene: ${JSON.stringify(e)}`),i.log(`Using sprite key: ${e.spriteKey}`);const s=t.add.sprite(0,0,e.spriteKey);s.scale=e.scale||1.5,s.name=e.id||"Error Missing Name",i.log(`NPC Sprite created with texture key ${e.spriteKey} at position (${e.startPosition.x}, ${e.startPosition.y})`);const o={id:e.id,sprite:s,walkingAnimationMapping:e.walkingAnimationMapping,startPosition:{x:a??e.startPosition.x,y:r??e.startPosition.y},speed:e.speed};if(i.log(`Grid engine config: ${JSON.stringify(o)}`),!t.textures.exists(e.spriteKey))throw new Error(`Texture with key ${e.spriteKey} does not exist in the scene`);t.gridEngine.addCharacter(o),i.log(`NPC added to grid engine with ID ${e.id}`),((l,d,u)=>{const h=t.gridEngine.getPosition(l.name);i.log(`Attaching NPC events to ${d} at position: ${JSON.stringify(h)}`),mt.attachNPCEvent(l,d,u,{coords:h})})(s,e.name,e.actions.map(l=>({label:l}))),i.log(`NPC ${e.name} added to scene successfully`)}catch(s){s instanceof Error?i.error(`Error adding NPC to scene from addNPCToScene: ${s.message}`):i.error("Error adding NPC to scene:",s)}}async addDialogue(t){await this.dialogues.put(t)}async getDialogue(t){return await this.dialogues.get(t)}async getAllDialogues(){return await this.dialogues.toArray()}async getDialoguesForNPC(t){const e=await this.getNPC(t);if(!e)throw new Error(`NPC with ID ${t} not found`);return(await Promise.all((e.dialogues||[]).map(r=>this.getDialogue(r.dialogueId)))).filter(r=>r!==void 0)}async markDialogueAsRead(t,e){const a=await this.getNPC(t);if(!a)throw new Error(`NPC with ID ${t} not found`);const r=a.dialogues?.find(s=>s.dialogueId===e);r&&(r.read=!0,await this.addNPC(a))}async fetchDialogues(t){try{const a=(await m.get(t)).data.key,r=Object.values(a).map(s=>({...s}));await this.dialogues.bulkPut(r)}catch(e){i.error(`Failed to fetch dialogues from ${t}:`,e)}}async getPrioritizedDialoguesForNPC(t){try{const e=await this.getNPC(t);if(!e)throw new Error(`NPC with ID ${t} not found`);const r=(await Promise.all((e.dialogues||[]).map(async s=>{const o=await this.getDialogue(s.dialogueId);return o?{...o,priority:s.priority,read:s.read}:null}))).filter(s=>s!==null);return r.sort((s,o)=>o.priority-s.priority),r}catch(e){return i.error(`Failed to get prioritized dialogues for NPC with ID ${t}:`,e),[]}}async getNPCNameById(t){return(await this.getNPC(t))?.name}async getNPCAvatarById(t){const e=await this.getNPC(t);if(e?.avatarImageId)return(await this.getAvatar(e.avatarImageId))?.avatarData}async getNPCSlugById(t){return(await this.getNPC(t))?.slug}async getNPCHealthById(t){try{return(await this.getNPC(t))?.stats?.health}catch(e){i.error(`Failed to get health for NPC with ID ${t}:`,e);return}}async getNPCManaById(t){try{return(await this.getNPC(t))?.stats?.mana}catch(e){i.error(`Failed to get mana for NPC with ID ${t}:`,e);return}}async createNPCSession(t,e){try{const a=this.getNPCNameById(e),r=this.getNPCSlugById(e),s=this.getNPCAvatarById(e),o=this.getNPCHealthById(e),n=this.getNPCManaById(e),[l,d,u,h,f]=await Promise.all([a,r,s,o,n]),g={...t.get(),[`${e}_name`]:l||"Unknown",[`${e}_slug`]:d||"Unknown",[`${e}_avatar`]:u?URL.createObjectURL(u):"Unknown",[`${e}_health`]:h||"100",[`${e}_mana`]:f||"100"};t.set(g)}catch{const r={...t.get(),[`${e}_name`]:"Unknown",[`${e}_slug`]:"Unknown",[`${e}_avatar`]:"Unknown",[`${e}_hp`]:"100",[`${e}_mana`]:"100"};t.set(r)}}async getNPCDialogueOptionsByULID(t){try{const e=await this.getDialogue(t);if(!e||!e.options)return"[]";const a=await Promise.all(e.options.map(async r=>this.getDialogue(r)));return JSON.stringify(a.filter(r=>r!==void 0))}catch(e){return i.error(`Failed to get dialogue options for ID ${t}:`,e),"[]"}}async getAllDialogueOptions(t){const e=[],a=new Set,r=async s=>{if(a.has(s))return;a.add(s);const o=await this.getDialogue(s);if(o&&(e.push(o),o.options&&o.options.length>0))for(const n of o.options)await r(n)};return await r(t),e}async createDialogueSession(t,e){try{const a=await this.getNPCDialogueOptionsByULID(e),r={...t.get(),[`${e}_options`]:a||"[]"};t.set(r)}catch{const r={...t.get(),[`${e}_options`]:"[]"};t.set(r)}}}const ft=new gt;class pt{constructor(){this.actionHandlers={talk:this.talkToNPC.bind(this),quest:this.questWithNPC.bind(this),trade:this.tradeWithNPC.bind(this),combat:this.startCombat.bind(this),heal:this.healNPC.bind(this),steal:this.stealFromNPC.bind(this),lore:this.loreFromNPC.bind(this)}}getActionHandler(t){return this.actionHandlers[t]}loreFromNPC(t){i.log(`Pulling up the lore of the NPC with ID: ${t.npcId}`)}questWithNPC(t){i.log(`Starting quest with NPC with ID: ${t.npcId}`)}healNPC(t){i.log(`Healing NPC with ID: ${t.npcId}`)}oathFromNPC(t){i.log(`Oath from NPC with ID: ${t.npcId}`)}async talkToNPC(t){try{i.log(`Talking to NPC with ID: ${t.npcId}`);const e=await ft.getPrioritizedDialoguesForNPC(t.npcId);if(i.log(e),e.length>0){const a=e[0];y.emit("npcDialogue",{npcId:t.npcId,dialogue:a},1e3)}else i.log("No dialogues available for this NPC.")}catch(e){i.error(`Failed to fetch dialogues for NPC with ID ${t.npcId}:`,e)}}tradeWithNPC(t){i.log(`Trading with NPC with ID: ${t.npcId}`)}moveToNPC(t){const a=t.data?.coords||{x:10,y:15};y.emit("playerMove",a)}stealFromNPC(t){i.log(`Attempting to steal from NPC with ID: ${t.npcId}`);const e={npcId:t.npcId,npcName:t.npcName,data:t.data};y.emit("playerSteal",e)}startCombat(t){i.log(`Starting combat with NPC with ID: ${t.npcId}`)}checkFish(t){i.log(`Checking fish for NPC with ID: ${t.npcId}`)}attachNPCEvent(t,e,a,r){t.setInteractive(),t.on("pointerover",s=>{const o={npcId:t.name||"",npcName:e,actions:a.map(n=>n.label),data:r||{},coords:{x:s.x,y:s.y}};y.emit("npcInteraction",o),t.setTint(65280)}),t.on("pointerout",()=>{t.clearTint()}),t.on("pointerdown",s=>{const o={npcId:t.name||"",npcName:e,actions:a.map(n=>n.label),data:r||{},coords:{x:s.x,y:s.y}};i.log(`Click Registered at X: ${o.coords.x} Y: ${o.coords.y}`),y.emit("npcInteractionClick",o,1e3)})}}const mt=new pt;export{$,i as D,F as K,_ as a,y as e,Nt as k};
