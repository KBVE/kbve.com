import{c as O}from"./@supabase.DtOst19a.js";import{D as E}from"./dexie.CB3rvRzt.js";import{a as T,p as J}from"./@nanostores.BerOGW42.js";import{t as B,m as j,a as M}from"./nanostores.Bo9-_MAV.js";import{a as g}from"./axios.dxcvQi4N.js";import{R,r as $,j as N}from"./react.B0RgU8Fg.js";const k={hcaptcha:"5ba581fa-b6fc-4bb0-8222-02fcd6a59e35",hcaptcha_api:"https://js.hcaptcha.com/1/api.js",api:"https://supabase.kbve.com",anonKey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ewogICJyb2xlIjogImFub24iLAogICJpc3MiOiAic3VwYWJhc2UiLAogICJpYXQiOiAxNzI0NTM2ODAwLAogICJleHAiOiAxODgyMzAzMjAwCn0._fmEmblm0afeLoPXxt8wP2mYpa9gzU-ufx3v8oRTFGg"},A={_state:{...k},get(){return{...this._state}},set(l){this._state={...this._state,...l}},reset(){this._state={...k}},toString(){return JSON.stringify(this._state,null,2)},getKey(l){return this._state[l]}},y="0123456789ABCDEFGHJKMNPQRSTVWXYZ";function z(l,t,e){for(;l.length<t;)l=e+l;return l}function W(){const l=Math.floor(Math.random()*y.length);return y.charAt(l)}function K(l){let t="";for(let e=0;e<l;e++)t+=W();return t}function q(l,t){let e="";for(let a=t-1;a>=0;a--){const r=l%y.length;e=y.charAt(r)+e,l=Math.floor(l/y.length)}return z(e,t,y[0])}function F(){const l=Date.now(),t=q(l,10),e=K(16),a=t+e;return{toString:()=>a,valueOf:()=>a}}const H={id:"",title:"",description:"",journals:[],isComplete:!1,reward:""},G={backpack:[],equipment:{head:null,body:null,legs:null,feet:null,hands:null,weapon:null,shield:null,accessory:null}},U={},V={inCombat:!1,isDead:!1,isResting:!1,activeBoosts:{}},Y={username:"Guest",health:"100",mana:"100",energy:"100",maxHealth:"100",maxMana:"100",maxEnergy:"100",armour:"0",agility:"0",strength:"0",intelligence:"0",experience:"0",reputation:"0",faith:"0"},X={stats:Y,inventory:G,state:V},Q={tooltipItem:{id:null,position:{x:0,y:0}},submenuItem:{id:null,position:{x:0,y:0}},tooltipNPC:{id:null,position:{x:0,y:0}},isStatsMenuCollapsed:!1,isSettingsMenuCollapsed:!1,debugMode:!1,textSpeed:40},Z={gamemode:"Idle",action:{type:"ROLL_DICE",diceValues:[],isRolling:!1},textures:{side1:"",side2:"",side3:"",side4:"",side5:"",side6:""}};function f(l,t){return T(l,t,{encode(e){return JSON.stringify(e)},decode(e){try{return JSON.parse(e)}catch{return t}}})}f("playerData",X);f("quest",H);f("items",U);f("notifications",[]);f("itemDB",U);const S=f("settings",Q);f("minigameState",Z);const tt=l=>S.get()[l],_=(l,t)=>{B(async()=>{const e=S.get();S.set({...e,[l]:t})})},et=()=>{_("debugMode",!0)},at=()=>{_("debugMode",!1)},v=()=>tt("debugMode"),C=l=>typeof l=="string"?l:JSON.stringify(l,null,2),st=l=>{v()&&console.log(`[DEBUG] ${C(l)}`)},rt=l=>{v()&&console.warn(`[DEBUG] ${C(l)}`)},it=(l,t)=>{v()&&(t instanceof Error?console.error(`[DEBUG] ${C(l)} - Error: ${t.message}
${t.stack}`):console.error(`[DEBUG] ${C(l)}`))},o={enable:et,disable:at,isEnabled:v,log:st,warn:rt,error:it};class ot{constructor(){this.events={},this.lastEmitted=new Map}on(t,e){this.events[t]||(this.events[t]=[]),this.events[t]?.push(e)}off(t,e){this.events[t]&&(this.events[t]=this.events[t]?.filter(a=>a!==e))}emit(t,e,a=0,r){const s=Date.now(),i=this.lastEmitted.get(t)||0;if(s-i>=a){if(!this.events[t])return;this.events[t]?.forEach(n=>n(e)),r&&o.isEnabled()&&o.log(`Event: ${String(t)} - Message: ${r}`),o.isEnabled()&&o.log(`Event Data: ${String(t)} - Data: ${e?JSON.stringify(e):"No data"}`),this.lastEmitted.set(t,s)}}}const p=new ot,I={id:"",email:"",updatedAt:new Date,fullName:"Guest",username:"Guest"},w=j(I),x=M(!1),P=M(null);class L extends E{constructor(){super("KilobaseDB"),this.supabase=null,this.profileKey="userProfile",this.handleUserRedirect=t=>{if(!t||!t.location)return;const{location:e,timer:a=0,replace:r=!1}=t;console.log(`Redirecting user to: ${e} in ${a}ms`),setTimeout(()=>{this.cleanupEventListeners(),r?window.location.replace(e):window.location.href=e},a)},this.version(1).stores({keyValueStore:"key",profiles:"&id, email",errorLogs:"++id, actionId, message, timestamp",actionULID:"&id, action, timestamp, status, errorId"}),this.profiles=this.table("profiles"),this.errorLogs=this.table("errorLogs"),this.actionULID=this.table("actionULID"),this.supabase=this.initializeSupabaseClient(),this.initializeEventListeners()}initializeEventListeners(){p.on("redirectUser",this.handleUserRedirect)}cleanupEventListeners(){p.off("redirectUser",this.handleUserRedirect)}initializeSupabaseClient(){if(typeof window<"u"&&window.supabase&&(console.log("Using global Supabase client instance:",window.supabase),this.supabase=window.supabase),!this.supabase)try{this.supabase=O(A.get().api,A.get().anonKey),console.log("Supabase client instance created:",this.supabase),typeof window<"u"&&(window.supabase=this.supabase)}catch(t){throw console.error("Error creating Supabase client:",t),t}return this.supabase}getSupabaseClient(){return this.supabase}async registerUser(t,e,a,r,s,i){const n=this.getSupabaseClient();if(!n)return null;try{if(e!==a)return await this.handleAuthError({message:"Password and confirm password do not match."},r),null;const{data:c,error:d}=await n.auth.signUp({email:t,password:e,options:{captchaToken:i,data:{username:s,full_name:s}}});if(d)return await this.handleAuthError(d,r),null;if(c?.user){const u={id:c.user.id,email:c.user.email||"",username:c.user.user_metadata?.username||void 0,fullName:c.user.user_metadata?.full_name||void 0,updatedAt:new Date(c.user.updated_at||Date.now())};return await this.saveProfile(u),await this.updateActionStatus(r,"completed"),u}}catch(c){return await this.handleAuthError(c,r),null}return null}async createActionULID(t){const e=F().toString(),a={id:e,action:t,timestamp:new Date,status:"pending"};return await this.actionULID.add(a),e}async handleAuthError(t,e){let a="An unknown error occurred. Please try again.",r={...t},s="";t?.message&&(a=t.message),t?.code&&(s+=`Error Code: ${t.code}. `),t?.status&&(s+=`Status: ${t.status}. `),t?.supabaseCode&&(s+=`Supabase Code: ${t.supabaseCode}. `),t?.details&&(s+=`Details: ${JSON.stringify(t.details)}. `),s&&(a=`${a} (${s.trim()})`);const i={invalid_grant:"Invalid credentials provided.",invalid_request:"The request is missing a required parameter.",expired_token:"The token has expired. Please log in again.",invalid_token:"The token provided is invalid. Please try again.",email_already_exists:"The email address is already in use.",user_already_exists:"A user with this identifier already exists. Please log in instead.",invalid_password:"The password provided is incorrect."};switch(t?.code&&i[t.code]&&(a=i[t.code]),t?.status){case 400:a="Bad request. Please check the input fields.";break;case 401:a="Unauthorized. Please check your credentials.";break;case 403:a="Forbidden. You do not have permission to perform this action.";break;case 404:a="Resource not found. Please try again.";break;case 422:a="Unprocessable entity. Please check the provided data.";break;case 500:a="Internal server error. Please try again later.";break;default:a=a||"An unknown error occurred. Please try again.";break}throw await this.logError(a,{...r,supabaseCode:t?.code,statusCode:t?.status},e),console.error("Authentication Error:",a),new Error(a)}async saveProfile(t){try{await this.table("keyValueStore").put({key:this.profileKey,value:t}),t.username&&P.set(t.username),w.set(t),console.log("Profile saved locally:",t)}catch(e){console.error("Failed to save profile locally:",e)}}async loadProfile(){try{const t=await this.table("keyValueStore").get(this.profileKey);if(t?.value){w.set(t.value),console.log("Profile loaded from local storage:",t.value);return}await this.loadProfileFromSupabase()}catch(t){console.error("Failed to load profile:",t)}}async loadProfileFromSupabase(){const t=this.getSupabaseClient();if(t)try{x.set(!0);const{data:{user:e},error:a}=await t.auth.getUser();if(a){console.error("Failed to get authenticated user from Supabase:",a),await this.logError("Failed to get authenticated user from Supabase",a);return}if(!e){console.warn("No authenticated user found");return}const{data:r,error:s}=await t.from("user_profiles").select("id, username, updated_at").eq("id",e.id).single();if(s){console.error("Failed to load user profile from Supabase:",s),await this.logError("Failed to load user profile from Supabase",s);return}if(r){const i={id:r.id,email:e.email||"",username:r.username||void 0,fullName:e.user_metadata?.full_name||void 0,updatedAt:new Date(r.updated_at)};await this.saveProfile(i),console.log("Profile loaded and saved from Supabase:",i)}}catch(e){console.error("An unexpected error occurred while loading the profile:",e),await this.logError("An unexpected error occurred while loading the profile",e)}finally{x.set(!1)}}async removeProfile(){const t=this.getSupabaseClient();if(t)try{const e=w.get();await this.table("keyValueStore").delete(this.profileKey),await this.profiles.delete(e.id),w.set(I),console.log(`Profile ${e.id} removed locally and store reset`),P.set(null);const{error:a}=await t.auth.signOut();a?(await this.logError("Failed to log out user from Supabase",a),console.error("Failed to log out user from Supabase:",a)):console.log("User logged out successfully from Supabase.")}catch(e){await this.logError("Failed to remove profile",e),console.error("Failed to remove profile:",e)}}async getProfile(){const t=w.get();if(t.id!=="")return t;try{const e=await this.table("keyValueStore").get(this.profileKey);if(e?.value){const a=e.value;return w.set(a),a}}catch(e){console.error("Failed to get profile from Dexie:",e)}return I}async createAction(t){const a={id:F().toString(),action:t,timestamp:new Date,status:"pending"};return await this.actionULID.add(a),a}async updateActionStatus(t,e,a){await this.actionULID.update(t,{status:e,errorId:a})}async logError(t,e,a){try{let r=null;if(a&&(r=await this.errorLogs.where("actionId").equals(a).first()),r){console.warn(`Error already exists for actionId: ${a}. Skipping new error log.`);return}const s={message:t,details:e,actionId:a,timestamp:new Date},i=await this.errorLogs.add(s);console.log("Error logged to Dexie:",s),a&&await this.updateActionStatus(a,"failed",i)}catch(r){console.error("Failed to log error:",r)}}async extractAuthErrorDetails(t){if(!t)return"Unknown error occurred. No error details available.";let e=t.message||"Unknown error occurred",a="";return t?.code&&(a+=`Error Code: ${t.code}. `),t?.status&&(a+=`Status: ${t.status}. `),t?.supabaseCode&&(a+=`Supabase Code: ${t.supabaseCode}. `),t?.details&&(a+=`Details: ${JSON.stringify(t.details)}. `),a&&(e=`${e} (${a.trim()})`),e}async getDetailedErrorByActionId(t){try{const e=await this.errorLogs.where("actionId").equals(t).last();return e?this.extractAuthErrorDetails(e):null}catch(e){return console.error(`Failed to retrieve detailed error for actionId: ${t}`,e),null}}async getErrorByActionId(t){try{const e=await this.errorLogs.where("actionId").equals(t).last();return e?e.message:null}catch(e){return console.error(`Failed to retrieve error for actionId: ${t}`,e),null}}async loginUser(t,e,a,r){const s=this.getSupabaseClient();if(!s)return null;try{const{data:i,error:n}=await s.auth.signInWithPassword({email:t,password:e,options:{captchaToken:r}});if(n)return await this.handleAuthError(n,a),null;if(i?.user){const c={id:i.user.id,email:i.user.email||"",username:i.user.user_metadata?.username||void 0,fullName:i.user.user_metadata?.full_name||void 0,updatedAt:new Date(i.user.updated_at||Date.now())};return await this.saveProfile(c),console.log("User logged in successfully:",c),c}}catch(i){return await this.handleAuthError(i,a),null}return null}async getSession(){const t=this.getSupabaseClient();if(!t)return null;try{const{data:e,error:a}=await t.auth.getSession();return a?(console.error("Failed to retrieve session:",a),null):e.session||null}catch(e){return console.error("Error getting session:",e),null}}async getUsername(){if(P.get())return P.get();try{const t=await this.table("keyValueStore").get(this.profileKey);if(t?.value?.username)return P.set(t.value.username),t.value.username}catch(t){console.error("Failed to get username from Dexie:",t)}return null}static createPersistentAtom(t,e){return T(t,e,{encode:JSON.stringify,decode:JSON.parse})}createPersistentMap(t,e){return J(t,e,{encode:JSON.stringify,decode:JSON.parse})}updateAtomField(t,e,a){t.set({...t.get(),[e]:a})}updateMapField(t,e,a){const s={...t.get(),[e]:a};t.set(s)}removeMapField(t,e){const a=t.get(),{[e]:r,...s}=a;t.set(s)}removeAtomField(t,e){const a=t.get(),{[e]:r,...s}=a;t.set(s)}resetState(t,e){t.set(e)}getPersistentAtom(t){return t.get()}}L.createPersistentAtom("atlas",{plugin:[]});const Pt=new L;class nt extends E{constructor(){super("MapDatabase"),this.version(1).stores({maps:"tilemapKey",jsonFiles:"tilemapKey",tilesetImages:"tilemapKey"}),this.maps=this.table("maps"),this.jsonFiles=this.table("jsonFiles"),this.tilesetImages=this.table("tilesetImages")}async initializeMapDatabase(){const t="/api/mapdb.json",e="https://kbve.com/api/mapdb.json";let a;try{a=(await g.get(t)).data,o.log(`Map database loaded from ${t}`)}catch{o.warn(`Failed to load map database from ${t}, trying fallback URL.`);try{a=(await g.get(e)).data,o.log(`Map database loaded from ${e}`)}catch{o.error(`Failed to load map database from both ${t} and ${e}`);return}}if(a&&a.key){for(const r in a.key)if(Object.prototype.hasOwnProperty.call(a.key,r)){const s=a.key[r];await this.addMap(s),await this.addJsonData(r,s.jsonDataUrl);const i=await this.fetchTilesetImage(s.tilesetImageUrl);i&&await this.addTilesetImage(r,i)}o.log("Map database initialized and data loaded.")}else o.error("Invalid map database format.")}async addMap(t){await this.maps.put(t)}async getMap(t){return await this.maps.get(t)}async addJsonData(t,e){await this.jsonFiles.put({tilemapKey:t,jsonData:e})}async getJsonData(t){return(await this.jsonFiles.get(t))?.jsonData}async addTilesetImage(t,e){await this.tilesetImages.put({tilemapKey:t,imageData:e})}async getTilesetImage(t){return(await this.tilesetImages.get(t))?.imageData}async getBounds(t){return(await this.maps.get(t))?.bounds}async getNpcsFromTilesetKey(t){const e=await lt.getMap(t);if(!e){o.error(`No map data found for tilesetKey: ${t}`);return}return e.npcs}async fetchMapData(t){try{return(await g.get(t)).data}catch(e){o.error(`Failed to fetch map data from ${t}:`,e);return}}async fetchJsonData(t){try{return(await g.get(t)).data}catch(e){o.error(`Failed to fetch JSON data from ${t}:`,e);return}}async fetchTilesetImage(t){try{return(await g.get(t,{responseType:"blob"})).data}catch(e){o.error(`Failed to fetch tileset image from ${t}:`,e);return}}async initializeMap(t,e,a,r){try{const s=await this.fetchMapData(e);if(s){await this.addMap(s);const i=await this.fetchJsonData(a);i&&await this.addJsonData(t,i);const n=await this.fetchTilesetImage(r);n&&await this.addTilesetImage(t,n)}}catch(s){o.error("Failed to initialize map database:",s)}}async loadMapIntoScene(t,e){const a=await this.getMap(e);if(!a){o.error(`Map with key ${e} not found`);return}const r=await this.getJsonData(e);if(!r){o.error(`JSON data for map ${e} not found`);return}const s=await this.getTilesetImage(e);if(!s){o.error(`Tileset image for map ${e} not found`);return}let i=null;try{i=URL.createObjectURL(s)}catch(n){o.error(`Failed to create object URL for tileset image: ${n}`);return}if(!i){o.error(`Tileset image URL for map ${e} could not be created.`);return}t.load.tilemapTiledJSON(e,r),t.load.image(a.tilesetKey,i),t.load.once("complete",()=>{const n=t.make.tilemap({key:e}),c=n.addTilesetImage(a.tilesetName,a.tilesetKey);if(c)for(let d=0;d<n.layers.length;d++){const u=n.createLayer(d,c,0,0);u?u.scale=a.scale:o.error(`Layer ${d} could not be created.`)}else o.error(`Tileset ${a.tilesetName} could not be created.`)}),t.load.start()}async loadMap(t,e){const a=await this.getMap(e);if(!a)throw new Error(`Map with key ${e} not found`);const r=await this.getJsonData(e);if(!r)throw new Error(`JSON data for map ${e} not found`);const s=await this.getTilesetImage(e);if(!s)throw new Error(`Tileset image for map ${e} not found`);let i=null;try{i=URL.createObjectURL(s)}catch(n){throw new Error(`Failed to create object URL for tileset image: ${n}`)}if(!i)throw new Error(`Tileset image URL for map ${e} could not be created.`);return t.load.tilemapTiledJSON(e,r),t.load.image(a.tilesetKey,i),new Promise(n=>{t.load.once("complete",()=>{const c=t.make.tilemap({key:e});if(c.addTilesetImage(a.tilesetName,a.tilesetKey)){for(let u=0;u<c.layers.length;u++){const h=c.createLayer(u,a.tilesetName,0,0);h?h.scale=a.scale:console.error(`Layer ${u} could not be created.`)}n(c)}else console.error(`Tileset ${a.tilesetName} could not be created.`),n(null)}),t.load.start()})}}const lt=new nt,ct=({text:l,speed:t=80,onComplete:e})=>{const[a,r]=$.useState([]),s=$.useRef([]);return $.useEffect(()=>{let i,n=0;const c=l.split(/(<\/?span[^>]*>)/g).filter(Boolean),d=[];c.forEach((h,b)=>{if(h.startsWith("<span")||h.startsWith("</span")){const m=h.match(/<span class="([^"]*)">/);if(m){const D=m[1];d.push(N.jsx("span",{className:D},`span-${b}`))}else d.push(N.jsx("span",{},`span-${b}`))}else h.split("").forEach((m,D)=>{d.push(N.jsx("span",{children:m},`char-${b}-${D}`))})}),n=0;const u=()=>{n<d.length?(s.current=[...s.current,d[n]],r([...s.current]),n++,i=window.setTimeout(u,t)):e&&e()};return s.current=[],r([]),u(),()=>{window.clearTimeout(i)}},[l,t,e]),N.jsx("div",{children:a})};R.memo(ct);class dt extends E{constructor(){super("NPCDatabase"),this.version(3).stores({npcs:"id,name",sprites:"id",avatars:"id",dialogues:"id"}),this.npcs=this.table("npcs"),this.sprites=this.table("sprites"),this.avatars=this.table("avatars"),this.dialogues=this.table("dialogues")}async addNPC(t){await this.npcs.put(t)}async getNPC(t){return await this.npcs.get(t)}async getNPCByName(t){return await this.npcs.where("name").equals(t).first()}async getAllNPCs(){return await this.npcs.toArray()}async exportNPCs(){const t=await this.getAllNPCs();return JSON.stringify(t,null,2)}async importNPCs(t){const e=JSON.parse(t);await this.npcs.bulkPut(e)}async fetchNPCData(t){try{return(await g.get(t)).data}catch(e){o.error(`Failed to fetch NPC data from ${t}:`,e);return}}async addSprite(t){await this.sprites.put(t)}async getSprite(t){return await this.sprites.get(t)}async getAllSprites(){return await this.sprites.toArray()}async addAvatar(t){await this.avatars.put(t)}async getAvatar(t){return await this.avatars.get(t)}async getAllAvatars(){return await this.avatars.toArray()}async urlToBlob(t){try{return(await g.get(t,{responseType:"blob"})).data}catch(e){o.error(`Failed to fetch blob from ${t}:`,e);return}}async addNewSprite(t,e){const a=await this.urlToBlob(t);if(a){const r={...e,spriteData:a};return await this.addSprite(r),r.id}}async addNewNPC(t,e,a){const r={...t,spriteImageId:e,avatarImageId:a};await this.addNPC(r)}async addNewAvatar(t,e){const a=await this.urlToBlob(t);if(a){const r={...e,avatarData:a};return await this.addAvatar(r),r.id}}async fetchAvatars(t){try{const a=(await g.get(t)).data.key;for(const r in a){const s=a[r];let i=await this.urlToBlob(s.avatarLocation);if(i||(i=await this.urlToBlob(`https://kbve.com${s.avatarLocation}`)),i){const n={id:s.id,avatarName:s.avatarName,avatarLocation:s.avatarLocation,avatarData:i,slug:s.slug};await this.addAvatar(n)}}}catch(e){o.error(`Failed to fetch avatars from ${t}:`,e)}}async fetchSprites(t){try{const a=(await g.get(t)).data.key;for(const r in a){const s=a[r];let i=await this.urlToBlob(s.assetLocation);if(i||(i=await this.urlToBlob(`https://kbve.com${s.assetLocation}`)),i){const n={id:s.id,spriteName:s.spriteName,assetLocation:s.assetLocation,frameWidth:s.frameWidth,frameHeight:s.frameHeight,scale:s.scale,slug:s.slug,spriteData:i};await this.addSprite(n)}}}catch(e){o.error(`Failed to fetch sprites from ${t}:`,e)}}async fetchNPCs(t){try{const a=(await g.get(t)).data.key;for(const r in a){const s=a[r],i={id:s.id,name:s.name,spriteKey:s.spriteKey,walkingAnimationMapping:s.walkingAnimationMapping,startPosition:s.startPosition,speed:s.speed,scale:s.scale,slug:s.slug,actions:s.actions,effects:s.effects,stats:s.stats,spriteImageId:s.spriteImageId,avatarImageId:s.avatarImageId,dialogues:s.dialogues||[]};await this.addNPC(i)}}catch(e){o.error(`Failed to fetch NPCs from ${t}:`,e)}}async initializeDatabase(t="https://kbve.com"){await this.fetchAvatars(`${t}/api/avatardb.json`),await this.fetchSprites(`${t}/api/spritedb.json`),await this.fetchNPCs(`${t}/api/npcdb.json`),await this.fetchDialogues(`${t}/api/dialogue.json`)}async loadNPC(t,e,a,r){try{o.log(`Loading NPC with name: ${e}`);const s=await this.getNPCByName(e);if(!s)throw new Error(`NPC with name ${e} not found`);o.log(`NPC Data: ${JSON.stringify(s)}`),await this.loadCharacter(t,s.id,a,r)}catch(s){s instanceof Error?o.error(`Failed to load NPC: ${s.message}`):o.error("Failed to load NPC:",s)}}async loadCharacter(t,e,a,r){try{o.log(`Loading NPC with ID: ${e}`);const s=await this.getNPC(e);if(!s)throw new Error(`NPC with ID ${e} not found`);o.log(`NPC Data: ${JSON.stringify(s)}`);const i=s.spriteKey;if(t.textures.exists(i))o.log(`Texture with key ${i} already loaded.`),this.addNPCToScene(t,s,a,r);else{o.log(`Texture with key ${i} not found, attempting to load.`);const n=await this.getSprite(s.spriteImageId);if(n&&n.spriteData){o.log(`Sprite Data: ${JSON.stringify(n)}`);const c=URL.createObjectURL(n.spriteData);t.load.spritesheet(i,c,{frameWidth:n.frameWidth,frameHeight:n.frameHeight}),t.load.once("complete",()=>{o.log(`Texture ${i} loaded successfully.`),this.addNPCToScene(t,s,a,r)}),t.load.start()}else throw new Error(`Sprite with ID ${s.spriteImageId} not found`)}}catch(s){s instanceof Error?o.error(`Failed to load NPC: ${s.message}`):o.error("Failed to load NPC:",s)}}addNPCToScene(t,e,a,r){try{o.log(`Adding NPC to scene: ${JSON.stringify(e)}`),o.log(`Using sprite key: ${e.spriteKey}`);const s=t.add.sprite(0,0,e.spriteKey);s.scale=e.scale||1.5,s.name=e.id||"Error Missing Name",o.log(`NPC Sprite created with texture key ${e.spriteKey} at position (${e.startPosition.x}, ${e.startPosition.y})`);const i={id:e.id,sprite:s,walkingAnimationMapping:e.walkingAnimationMapping,startPosition:{x:a??e.startPosition.x,y:r??e.startPosition.y},speed:e.speed};if(o.log(`Grid engine config: ${JSON.stringify(i)}`),!t.textures.exists(e.spriteKey))throw new Error(`Texture with key ${e.spriteKey} does not exist in the scene`);t.gridEngine.addCharacter(i),o.log(`NPC added to grid engine with ID ${e.id}`),((c,d,u)=>{const h=t.gridEngine.getPosition(c.name);o.log(`Attaching NPC events to ${d} at position: ${JSON.stringify(h)}`),gt.attachNPCEvent(c,d,u,{coords:h})})(s,e.name,e.actions.map(c=>({label:c}))),o.log(`NPC ${e.name} added to scene successfully`)}catch(s){s instanceof Error?o.error(`Error adding NPC to scene from addNPCToScene: ${s.message}`):o.error("Error adding NPC to scene:",s)}}async addDialogue(t){await this.dialogues.put(t)}async getDialogue(t){return await this.dialogues.get(t)}async getAllDialogues(){return await this.dialogues.toArray()}async getDialoguesForNPC(t){const e=await this.getNPC(t);if(!e)throw new Error(`NPC with ID ${t} not found`);return(await Promise.all((e.dialogues||[]).map(r=>this.getDialogue(r.dialogueId)))).filter(r=>r!==void 0)}async markDialogueAsRead(t,e){const a=await this.getNPC(t);if(!a)throw new Error(`NPC with ID ${t} not found`);const r=a.dialogues?.find(s=>s.dialogueId===e);r&&(r.read=!0,await this.addNPC(a))}async fetchDialogues(t){try{const a=(await g.get(t)).data.key,r=Object.values(a).map(s=>({...s}));await this.dialogues.bulkPut(r)}catch(e){o.error(`Failed to fetch dialogues from ${t}:`,e)}}async getPrioritizedDialoguesForNPC(t){try{const e=await this.getNPC(t);if(!e)throw new Error(`NPC with ID ${t} not found`);const r=(await Promise.all((e.dialogues||[]).map(async s=>{const i=await this.getDialogue(s.dialogueId);return i?{...i,priority:s.priority,read:s.read}:null}))).filter(s=>s!==null);return r.sort((s,i)=>i.priority-s.priority),r}catch(e){return o.error(`Failed to get prioritized dialogues for NPC with ID ${t}:`,e),[]}}async getNPCNameById(t){return(await this.getNPC(t))?.name}async getNPCAvatarById(t){const e=await this.getNPC(t);if(e?.avatarImageId)return(await this.getAvatar(e.avatarImageId))?.avatarData}async getNPCSlugById(t){return(await this.getNPC(t))?.slug}async getNPCHealthById(t){try{return(await this.getNPC(t))?.stats?.health}catch(e){o.error(`Failed to get health for NPC with ID ${t}:`,e);return}}async getNPCManaById(t){try{return(await this.getNPC(t))?.stats?.mana}catch(e){o.error(`Failed to get mana for NPC with ID ${t}:`,e);return}}async createNPCSession(t,e){try{const a=this.getNPCNameById(e),r=this.getNPCSlugById(e),s=this.getNPCAvatarById(e),i=this.getNPCHealthById(e),n=this.getNPCManaById(e),[c,d,u,h,b]=await Promise.all([a,r,s,i,n]),m={...t.get(),[`${e}_name`]:c||"Unknown",[`${e}_slug`]:d||"Unknown",[`${e}_avatar`]:u?URL.createObjectURL(u):"Unknown",[`${e}_health`]:h||"100",[`${e}_mana`]:b||"100"};t.set(m)}catch{const r={...t.get(),[`${e}_name`]:"Unknown",[`${e}_slug`]:"Unknown",[`${e}_avatar`]:"Unknown",[`${e}_hp`]:"100",[`${e}_mana`]:"100"};t.set(r)}}async getNPCDialogueOptionsByULID(t){try{const e=await this.getDialogue(t);if(!e||!e.options)return"[]";const a=await Promise.all(e.options.map(async r=>this.getDialogue(r)));return JSON.stringify(a.filter(r=>r!==void 0))}catch(e){return o.error(`Failed to get dialogue options for ID ${t}:`,e),"[]"}}async getAllDialogueOptions(t){const e=[],a=new Set,r=async s=>{if(a.has(s))return;a.add(s);const i=await this.getDialogue(s);if(i&&(e.push(i),i.options&&i.options.length>0))for(const n of i.options)await r(n)};return await r(t),e}async createDialogueSession(t,e){try{const a=await this.getNPCDialogueOptionsByULID(e),r={...t.get(),[`${e}_options`]:a||"[]"};t.set(r)}catch{const r={...t.get(),[`${e}_options`]:"[]"};t.set(r)}}}const ut=new dt;class ht{constructor(){this.actionHandlers={talk:this.talkToNPC.bind(this),quest:this.questWithNPC.bind(this),trade:this.tradeWithNPC.bind(this),combat:this.startCombat.bind(this),heal:this.healNPC.bind(this),steal:this.stealFromNPC.bind(this),lore:this.loreFromNPC.bind(this)}}getActionHandler(t){return this.actionHandlers[t]}loreFromNPC(t){o.log(`Pulling up the lore of the NPC with ID: ${t.npcId}`)}questWithNPC(t){o.log(`Starting quest with NPC with ID: ${t.npcId}`)}healNPC(t){o.log(`Healing NPC with ID: ${t.npcId}`)}oathFromNPC(t){o.log(`Oath from NPC with ID: ${t.npcId}`)}async talkToNPC(t){try{o.log(`Talking to NPC with ID: ${t.npcId}`);const e=await ut.getPrioritizedDialoguesForNPC(t.npcId);if(o.log(e),e.length>0){const a=e[0];p.emit("npcDialogue",{npcId:t.npcId,dialogue:a},1e3)}else o.log("No dialogues available for this NPC.")}catch(e){o.error(`Failed to fetch dialogues for NPC with ID ${t.npcId}:`,e)}}tradeWithNPC(t){o.log(`Trading with NPC with ID: ${t.npcId}`)}moveToNPC(t){const a=t.data?.coords||{x:10,y:15};p.emit("playerMove",a)}stealFromNPC(t){o.log(`Attempting to steal from NPC with ID: ${t.npcId}`);const e={npcId:t.npcId,npcName:t.npcName,data:t.data};p.emit("playerSteal",e)}startCombat(t){o.log(`Starting combat with NPC with ID: ${t.npcId}`)}checkFish(t){o.log(`Checking fish for NPC with ID: ${t.npcId}`)}attachNPCEvent(t,e,a,r){t.setInteractive(),t.on("pointerover",s=>{const i={npcId:t.name||"",npcName:e,actions:a.map(n=>n.label),data:r||{},coords:{x:s.x,y:s.y}};p.emit("npcInteraction",i),t.setTint(65280)}),t.on("pointerout",()=>{t.clearTint()}),t.on("pointerdown",s=>{const i={npcId:t.name||"",npcName:e,actions:a.map(n=>n.label),data:r||{},coords:{x:s.x,y:s.y}};o.log(`Click Registered at X: ${i.coords.x} Y: ${i.coords.y}`),p.emit("npcInteractionClick",i,1e3)})}}const gt=new ht;export{w as $,o as D,A as K,L as a,p as e,Pt as k};
