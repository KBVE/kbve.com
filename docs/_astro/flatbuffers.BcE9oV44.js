var l=(t=>(t[t.WIDTH8=0]="WIDTH8",t[t.WIDTH16=1]="WIDTH16",t[t.WIDTH32=2]="WIDTH32",t[t.WIDTH64=3]="WIDTH64",t))(l||{});function B(t){return 1<<t}function F(t){return t>=-128&&t<=127?l.WIDTH8:t>=-32768&&t<=32767?l.WIDTH16:t>=-2147483648&&t<=2147483647?l.WIDTH32:l.WIDTH64}function H(t){return t===Math.fround(t)?l.WIDTH32:l.WIDTH64}function y(t){return t<=255?l.WIDTH8:t<=65535?l.WIDTH16:t<=4294967295?l.WIDTH32:l.WIDTH64}function p(t){return 1===t?l.WIDTH8:2===t?l.WIDTH16:4===t?l.WIDTH32:l.WIDTH64}function D(t,e){return 1+~t&e-1}function m(t){return(new TextDecoder).decode(t)}function U(t){return(new TextEncoder).encode(t)}var n=(t=>(t[t.NULL=0]="NULL",t[t.INT=1]="INT",t[t.UINT=2]="UINT",t[t.FLOAT=3]="FLOAT",t[t.KEY=4]="KEY",t[t.STRING=5]="STRING",t[t.INDIRECT_INT=6]="INDIRECT_INT",t[t.INDIRECT_UINT=7]="INDIRECT_UINT",t[t.INDIRECT_FLOAT=8]="INDIRECT_FLOAT",t[t.MAP=9]="MAP",t[t.VECTOR=10]="VECTOR",t[t.VECTOR_INT=11]="VECTOR_INT",t[t.VECTOR_UINT=12]="VECTOR_UINT",t[t.VECTOR_FLOAT=13]="VECTOR_FLOAT",t[t.VECTOR_KEY=14]="VECTOR_KEY",t[t.VECTOR_STRING_DEPRECATED=15]="VECTOR_STRING_DEPRECATED",t[t.VECTOR_INT2=16]="VECTOR_INT2",t[t.VECTOR_UINT2=17]="VECTOR_UINT2",t[t.VECTOR_FLOAT2=18]="VECTOR_FLOAT2",t[t.VECTOR_INT3=19]="VECTOR_INT3",t[t.VECTOR_UINT3=20]="VECTOR_UINT3",t[t.VECTOR_FLOAT3=21]="VECTOR_FLOAT3",t[t.VECTOR_INT4=22]="VECTOR_INT4",t[t.VECTOR_UINT4=23]="VECTOR_UINT4",t[t.VECTOR_FLOAT4=24]="VECTOR_FLOAT4",t[t.BLOB=25]="BLOB",t[t.BOOL=26]="BOOL",t[t.VECTOR_BOOL=36]="VECTOR_BOOL",t))(n||{});function E(t){return t===n.BOOL||t<=n.FLOAT}function A(t){return t>=n.INT&&t<=n.FLOAT}function P(t){return t>=n.INDIRECT_INT&&t<=n.INDIRECT_FLOAT}function K(t){return t===n.BOOL||t>=n.INT&&t<=n.STRING}function S(t){return t===n.VECTOR_BOOL||t>=n.VECTOR_INT&&t<=n.VECTOR_STRING_DEPRECATED}function _(t){return t>=n.VECTOR_INT2&&t<=n.VECTOR_FLOAT4}function V(t){return S(t)||_(t)||t===n.VECTOR}function $(t,e){if(0===e)return t-n.INT+n.VECTOR_INT;if(2===e)return t-n.INT+n.VECTOR_INT2;if(3===e)return t-n.INT+n.VECTOR_INT3;if(4===e)return t-n.INT+n.VECTOR_INT4;throw"Unexpected length "+e}function x(t){return t-n.VECTOR_INT+n.INT}function Y(t){return(t-n.VECTOR_INT2)%3+n.INT}function M(t){return 2+((t-n.VECTOR_INT2)/3|0)}function L(t,e){return e|t<<2}class b{constructor(t,e,i,s=null,n=0){this.builder=t,this.type=e,this.width=i,this.value=s,this.offset=n}elementWidth(t,e){if(E(this.type))return this.width;for(let i=0;i<4;i++){const s=1<<i,n=y(t+D(t,s)+e*s-this.offset);if(1<<n===s)return n}throw`Element is unknown. Size: ${t} at index: ${e}. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new`}writeToBuffer(t){const e=this.builder.computeOffset(t);if(this.type===n.FLOAT)this.width===l.WIDTH32?this.builder.view.setFloat32(this.builder.offset,this.value,!0):this.builder.view.setFloat64(this.builder.offset,this.value,!0);else if(this.type===n.INT){const e=p(t);this.builder.pushInt(this.value,e)}else if(this.type===n.UINT){const e=p(t);this.builder.pushUInt(this.value,e)}else if(this.type===n.NULL)this.builder.pushInt(0,this.width);else{if(this.type!==n.BOOL)throw`Unexpected type: ${this.type}. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new`;this.builder.pushInt(this.value?1:0,this.width)}this.offset=e}storedWidth(t=l.WIDTH8){return E(this.type)?Math.max(t,this.width):this.width}storedPackedType(t=l.WIDTH8){return L(this.type,this.storedWidth(t))}isOffset(){return!E(this.type)}}class z{constructor(t=2048,e=!0,i=!0,s=!0){this.dedupStrings=e,this.dedupKeys=i,this.dedupKeyVectors=s,this.stack=[],this.stackPointers=[],this.offset=0,this.finished=!1,this.stringLookup={},this.keyLookup={},this.keyVectorLookup={},this.indirectIntLookup={},this.indirectUIntLookup={},this.indirectFloatLookup={},this.buffer=new ArrayBuffer(t>0?t:2048),this.view=new DataView(this.buffer)}align(t){const e=B(t);return this.offset+=D(this.offset,e),e}computeOffset(t){const e=this.offset+t;let i=this.buffer.byteLength;const s=i;for(;i<e;)i<<=1;if(s<i){const t=this.buffer;this.buffer=new ArrayBuffer(i),this.view=new DataView(this.buffer),new Uint8Array(this.buffer).set(new Uint8Array(t),0)}return e}pushInt(t,e){if(e===l.WIDTH8)this.view.setInt8(this.offset,t);else if(e===l.WIDTH16)this.view.setInt16(this.offset,t,!0);else if(e===l.WIDTH32)this.view.setInt32(this.offset,t,!0);else{if(e!==l.WIDTH64)throw`Unexpected width: ${e} for value: ${t}`;this.view.setBigInt64(this.offset,BigInt(t),!0)}}pushUInt(t,e){if(e===l.WIDTH8)this.view.setUint8(this.offset,t);else if(e===l.WIDTH16)this.view.setUint16(this.offset,t,!0);else if(e===l.WIDTH32)this.view.setUint32(this.offset,t,!0);else{if(e!==l.WIDTH64)throw`Unexpected width: ${e} for value: ${t}`;this.view.setBigUint64(this.offset,BigInt(t),!0)}}writeInt(t,e){const i=this.computeOffset(e);this.pushInt(t,p(e)),this.offset=i}writeUInt(t,e){const i=this.computeOffset(e);this.pushUInt(t,p(e)),this.offset=i}writeBlob(t){const e=t.byteLength,i=y(e),s=this.align(i);this.writeUInt(e,s);const h=this.offset,r=this.computeOffset(e);new Uint8Array(this.buffer).set(new Uint8Array(t),h),this.stack.push(this.offsetStackValue(h,n.BLOB,i)),this.offset=r}writeString(t){if(this.dedupStrings&&Object.prototype.hasOwnProperty.call(this.stringLookup,t))return void this.stack.push(this.stringLookup[t]);const e=U(t),i=e.length,s=y(i),h=this.align(s);this.writeUInt(i,h);const r=this.offset,o=this.computeOffset(i+1);new Uint8Array(this.buffer).set(e,r);const a=this.offsetStackValue(r,n.STRING,s);this.stack.push(a),this.dedupStrings&&(this.stringLookup[t]=a),this.offset=o}writeKey(t){if(this.dedupKeys&&Object.prototype.hasOwnProperty.call(this.keyLookup,t))return void this.stack.push(this.keyLookup[t]);const e=U(t),i=e.length,s=this.computeOffset(i+1);new Uint8Array(this.buffer).set(e,this.offset);const h=this.offsetStackValue(this.offset,n.KEY,l.WIDTH8);this.stack.push(h),this.dedupKeys&&(this.keyLookup[t]=h),this.offset=s}writeStackValue(t,e){const i=this.computeOffset(e);if(t.isOffset()){const i=this.offset-t.offset;if(!(8===e||BigInt(i)<BigInt(1)<<BigInt(8*e)))throw`Unexpected size ${e}. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new`;this.writeUInt(i,e)}else t.writeToBuffer(e);this.offset=i}integrityCheckOnValueAddition(){if(this.finished)throw"Adding values after finish is prohibited";if(0!==this.stackPointers.length&&!1===this.stackPointers[this.stackPointers.length-1].isVector&&this.stack[this.stack.length-1].type!==n.KEY)throw"Adding value to a map before adding a key is prohibited"}integrityCheckOnKeyAddition(){if(this.finished)throw"Adding values after finish is prohibited";if(0===this.stackPointers.length||this.stackPointers[this.stackPointers.length-1].isVector)throw"Adding key before starting a map is prohibited"}startVector(){this.stackPointers.push({stackPosition:this.stack.length,isVector:!0})}startMap(t=!1){this.stackPointers.push({stackPosition:this.stack.length,isVector:!1,presorted:t})}endVector(t){const e=this.stack.length-t.stackPosition,i=this.createVector(t.stackPosition,e,1);this.stack.splice(t.stackPosition,e),this.stack.push(i)}endMap(t){t.presorted||this.sort(t);let e="";for(let i=t.stackPosition;i<this.stack.length;i+=2)e+=`,${this.stack[i].offset}`;const i=this.stack.length-t.stackPosition>>1;this.dedupKeyVectors&&!Object.prototype.hasOwnProperty.call(this.keyVectorLookup,e)&&(this.keyVectorLookup[e]=this.createVector(t.stackPosition,i,2));const s=this.dedupKeyVectors?this.keyVectorLookup[e]:this.createVector(t.stackPosition,i,2),n=this.createVector(t.stackPosition+1,i,2,s);this.stack.splice(t.stackPosition,i<<1),this.stack.push(n)}sort(t){const e=this.view,i=this.stack;function s(t,i){if(t.type!==n.KEY||i.type!==n.KEY)throw`Stack values are not keys ${t} | ${i}. Check if you combined [addKey] with add... method calls properly.`;let s,h,r=0;do{if(s=e.getUint8(t.offset+r),h=e.getUint8(i.offset+r),h<s)return!0;if(s<h)return!1;r+=1}while(0!==s&&0!==h);return!1}function h(t,e,i){if(e===i)return;const s=t[e],n=t[e+1];t[e]=t[i],t[e+1]=t[i+1],t[i]=s,t[i+1]=n}function r(t,i){if(t.type!==n.KEY||i.type!==n.KEY)throw`Stack values are not keys ${t} | ${i}. Check if you combined [addKey] with add... method calls properly.`;if(t.offset===i.offset)return!1;let s,h,r=0;do{if(s=e.getUint8(t.offset+r),h=e.getUint8(i.offset+r),s<h)return!0;if(h<s)return!1;r+=1}while(0!==s&&0!==h);return!1}let o=!0;for(let e=t.stackPosition;e<this.stack.length-2;e+=2)if(s(this.stack[e],this.stack[e+2])){o=!1;break}o||(this.stack.length-t.stackPosition>40?function t(e,s){if(e<s){const n=i[e+2*(s-e>>2)];let o=e,a=s;do{for(;r(i[o],n);)o+=2;for(;r(n,i[a]);)a-=2;o<=a&&(h(i,o,a),o+=2,a-=2)}while(o<=a);t(e,a),t(o,s)}}(t.stackPosition,this.stack.length-2):function(){for(let e=t.stackPosition;e<i.length;e+=2){let t=e;for(let n=e+2;n<i.length;n+=2)s(i[t],i[n])&&(t=n);t!==e&&h(i,t,e)}}())}end(){if(this.stackPointers.length<1)return;const t=this.stackPointers.pop();t.isVector?this.endVector(t):this.endMap(t)}createVector(t,e,i,s=null){let h=y(e),r=1;if(null!==s){const t=s.elementWidth(this.offset,0);t>h&&(h=t),r+=2}let o=n.KEY,a=null===s;for(let e=t;e<this.stack.length;e+=i){const i=this.stack[e].elementWidth(this.offset,e+r);i>h&&(h=i),e===t?(o=this.stack[e].type,a=a&&K(o)):o!==this.stack[e].type&&(a=!1)}const f=this.align(h),u=a&&A(o)&&e>=2&&e<=4;null!==s&&(this.writeStackValue(s,f),this.writeUInt(1<<s.width,f)),u||this.writeUInt(e,f);const l=this.offset;for(let e=t;e<this.stack.length;e+=i)this.writeStackValue(this.stack[e],f);if(!a)for(let e=t;e<this.stack.length;e+=i)this.writeUInt(this.stack[e].storedPackedType(),1);if(null!==s)return this.offsetStackValue(l,n.MAP,h);if(a){const t=$(o,u?e:0);return this.offsetStackValue(l,t,h)}return this.offsetStackValue(l,n.VECTOR,h)}nullStackValue(){return new b(this,n.NULL,l.WIDTH8)}boolStackValue(t){return new b(this,n.BOOL,l.WIDTH8,t)}intStackValue(t){return new b(this,n.INT,F(t),t)}uintStackValue(t){return new b(this,n.UINT,y(t),t)}floatStackValue(t){return new b(this,n.FLOAT,H(t),t)}offsetStackValue(t,e,i){return new b(this,e,i,null,t)}finishBuffer(){if(1!==this.stack.length)throw`Stack has to be exactly 1, but it is ${this.stack.length}. You have to end all started vectors and maps before calling [finish]`;const t=this.stack[0],e=this.align(t.elementWidth(this.offset,0));this.writeStackValue(t,e),this.writeUInt(t.storedPackedType(),1),this.writeUInt(e,1),this.finished=!0}add(t){if(this.integrityCheckOnValueAddition(),typeof t>"u")throw"You need to provide a value";if(null===t)this.stack.push(this.nullStackValue());else if("boolean"==typeof t)this.stack.push(this.boolStackValue(t));else if("bigint"==typeof t)this.stack.push(this.intStackValue(t));else if("number"==typeof t)Number.isInteger(t)?this.stack.push(this.intStackValue(t)):this.stack.push(this.floatStackValue(t));else if(ArrayBuffer.isView(t))this.writeBlob(t.buffer);else if("string"==typeof t||t instanceof String)this.writeString(t);else if(Array.isArray(t)){this.startVector();for(let e=0;e<t.length;e++)this.add(t[e]);this.end()}else{if("object"!=typeof t)throw`Unexpected value input ${t}`;{const e=Object.getOwnPropertyNames(t).sort();this.startMap(!0);for(let i=0;i<e.length;i++){const s=e[i];this.addKey(s),this.add(t[s])}this.end()}}}finish(){this.finished||this.finishBuffer();const t=this.buffer.slice(0,this.offset);return new Uint8Array(t)}isFinished(){return this.finished}addKey(t){this.integrityCheckOnKeyAddition(),this.writeKey(t)}addInt(t,e=!1,i=!1){if(this.integrityCheckOnValueAddition(),!e)return void this.stack.push(this.intStackValue(t));if(i&&Object.prototype.hasOwnProperty.call(this.indirectIntLookup,t))return void this.stack.push(this.indirectIntLookup[t]);const s=this.intStackValue(t),h=this.align(s.width),r=this.computeOffset(h),o=this.offset;s.writeToBuffer(h);const a=this.offsetStackValue(o,n.INDIRECT_INT,s.width);this.stack.push(a),this.offset=r,i&&(this.indirectIntLookup[t]=a)}addUInt(t,e=!1,i=!1){if(this.integrityCheckOnValueAddition(),!e)return void this.stack.push(this.uintStackValue(t));if(i&&Object.prototype.hasOwnProperty.call(this.indirectUIntLookup,t))return void this.stack.push(this.indirectUIntLookup[t]);const s=this.uintStackValue(t),h=this.align(s.width),r=this.computeOffset(h),o=this.offset;s.writeToBuffer(h);const a=this.offsetStackValue(o,n.INDIRECT_UINT,s.width);this.stack.push(a),this.offset=r,i&&(this.indirectUIntLookup[t]=a)}addFloat(t,e=!1,i=!1){if(this.integrityCheckOnValueAddition(),!e)return void this.stack.push(this.floatStackValue(t));if(i&&Object.prototype.hasOwnProperty.call(this.indirectFloatLookup,t))return void this.stack.push(this.indirectFloatLookup[t]);const s=this.floatStackValue(t),h=this.align(s.width),r=this.computeOffset(h),o=this.offset;s.writeToBuffer(h);const a=this.offsetStackValue(o,n.INDIRECT_FLOAT,s.width);this.stack.push(a),this.offset=r,i&&(this.indirectFloatLookup[t]=a)}}function W(t,e,i){return i<2?i<1?t.getInt8(e):t.getInt16(e,!0):i<3?t.getInt32(e,!0):void 0===t.setBigInt64?BigInt(t.getUint32(e,!0))+(BigInt(t.getUint32(e+4,!0))<<BigInt(32)):t.getBigInt64(e,!0)}function k(t,e,i){return i<2?i<1?t.getUint8(e):t.getUint16(e,!0):i<3?t.getUint32(e,!0):void 0===t.getBigUint64?BigInt(t.getUint32(e,!0))+(BigInt(t.getUint32(e+4,!0))<<BigInt(32)):t.getBigUint64(e,!0)}function R(t,e,i){if(i<l.WIDTH32)throw"Bad width: "+i;return i===l.WIDTH32?t.getFloat32(e,!0):t.getFloat64(e,!0)}function g(t,e,i){return e-k(t,e,i)}function j(t,e,i,s,n,h){const r=U(t),o=g(e,i,s)-3*n,a=p(n),f=o-Number(k(e,o,a)),u=Number(k(e,o+n,a));let l=0,c=h-1;for(;l<=c;){const t=c+l>>1,i=G(r,t,e,f,u);if(0===i)return t;i<0?c=t-1:l=t+1}return null}function G(t,e,i,s,n){const h=s+e*n,r=h-Number(k(i,h,p(n)));for(let e=0;e<t.length;e++){const s=t[e]-i.getUint8(r+e);if(0!==s)return s}return 0===i.getUint8(r+t.length)?0:-1}function v(t,e,i,s,n){const h=g(e,i,s)-3*n,r=p(n),o=h-Number(k(e,h,r)),a=Number(k(e,h+n,r)),f=o+t*a,u=f-Number(k(e,f,p(a)));let l=0;for(;0!==e.getUint8(u+l);)l++;return m(new Uint8Array(e.buffer,u,l))}function q(t){const e=t.byteLength;if(e<3)throw"Buffer needs to be bigger than 3";const i=new DataView(t),s=i.getUint8(e-1),n=i.getUint8(e-2),h=p(s);return new N(i,e-s-2,h,n,"/")}function C(t,e,i,s,n,h,r,o){const a=g(i,s,n),f=a+t*h,u=i.getUint8(a+r*h+t);return new N(i,f,p(h),u,`${o}/${e}`)}class N{constructor(t,e,i,s,n){this.dataView=t,this.offset=e,this.parentWidth=i,this.packedType=s,this.path=n,this._length=-1,this.byteWidth=1<<(3&s),this.valueType=s>>2}isNull(){return this.valueType===n.NULL}isNumber(){return A(this.valueType)||P(this.valueType)}isFloat(){return n.FLOAT===this.valueType||n.INDIRECT_FLOAT===this.valueType}isInt(){return this.isNumber()&&!this.isFloat()}isString(){return n.STRING===this.valueType||n.KEY===this.valueType}isBool(){return n.BOOL===this.valueType}isBlob(){return n.BLOB===this.valueType}isVector(){return V(this.valueType)}isMap(){return n.MAP===this.valueType}boolValue(){return this.isBool()?W(this.dataView,this.offset,this.parentWidth)>0:null}intValue(){return this.valueType===n.INT?W(this.dataView,this.offset,this.parentWidth):this.valueType===n.UINT?k(this.dataView,this.offset,this.parentWidth):this.valueType===n.INDIRECT_INT?W(this.dataView,g(this.dataView,this.offset,this.parentWidth),p(this.byteWidth)):this.valueType===n.INDIRECT_UINT?k(this.dataView,g(this.dataView,this.offset,this.parentWidth),p(this.byteWidth)):null}floatValue(){return this.valueType===n.FLOAT?R(this.dataView,this.offset,this.parentWidth):this.valueType===n.INDIRECT_FLOAT?R(this.dataView,g(this.dataView,this.offset,this.parentWidth),p(this.byteWidth)):null}numericValue(){return this.floatValue()||this.intValue()}stringValue(){if(this.valueType===n.STRING||this.valueType===n.KEY){const t=g(this.dataView,this.offset,this.parentWidth);return m(new Uint8Array(this.dataView.buffer,t,this.length()))}return null}blobValue(){if(this.isBlob()){const t=g(this.dataView,this.offset,this.parentWidth);return new Uint8Array(this.dataView.buffer,t,this.length())}return null}get(t){const e=this.length();if(Number.isInteger(t)&&V(this.valueType)){if(t>=e||t<0)throw`Key: [${t}] is not applicable on ${this.path} of ${this.valueType} length: ${e}`;const i=g(this.dataView,this.offset,this.parentWidth),s=i+t*this.byteWidth;let n=this.dataView.getUint8(i+e*this.byteWidth+t);if(S(this.valueType)){n=L(x(this.valueType),l.WIDTH8)}else if(_(this.valueType)){n=L(Y(this.valueType),l.WIDTH8)}return new N(this.dataView,s,p(this.byteWidth),n,`${this.path}[${t}]`)}if("string"==typeof t){const i=j(t,this.dataView,this.offset,this.parentWidth,this.byteWidth,e);if(null!==i)return C(i,t,this.dataView,this.offset,this.parentWidth,this.byteWidth,e,this.path)}throw`Key [${t}] is not applicable on ${this.path} of ${this.valueType}`}length(){let t;if(this._length>-1)return this._length;if(_(this.valueType))this._length=M(this.valueType);else if(this.valueType===n.BLOB||this.valueType===n.MAP||V(this.valueType))this._length=k(this.dataView,g(this.dataView,this.offset,this.parentWidth)-this.byteWidth,p(this.byteWidth));else if(this.valueType===n.NULL)this._length=0;else if(this.valueType===n.STRING){const e=g(this.dataView,this.offset,this.parentWidth);let i=this.byteWidth;for(t=k(this.dataView,e-i,p(this.byteWidth));0!==this.dataView.getInt8(e+t);)i<<=1,t=k(this.dataView,e-i,p(this.byteWidth));this._length=t}else if(this.valueType===n.KEY){const e=g(this.dataView,this.offset,this.parentWidth);for(t=1;0!==this.dataView.getInt8(e+t);)t++;this._length=t}else this._length=1;return Number(this._length)}toObject(){const t=this.length();if(this.isVector()){const e=[];for(let i=0;i<t;i++)e.push(this.get(i).toObject());return e}if(this.isMap()){const e={};for(let i=0;i<t;i++){const s=v(i,this.dataView,this.offset,this.parentWidth,this.byteWidth);e[s]=C(i,s,this.dataView,this.offset,this.parentWidth,this.byteWidth,t,this.path).toObject()}return e}return this.isNull()?null:this.isBool()?this.boolValue():this.isNumber()?this.numericValue():this.blobValue()||this.stringValue()}}export{z as B,q as t};